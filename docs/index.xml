<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PDI – About</title>
    <link>http://pdi.julien-bigot.fr/new-site/docs/</link>
    <description>Recent content in About on PDI</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="http://pdi.julien-bigot.fr/new-site/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Core Concepts</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/concepts/</guid>
      <description>
        
        
        &lt;h2 id=&#34;philosophy-of-pdi&#34;&gt;Philosophy of PDI&lt;/h2&gt;
&lt;p&gt;Similarly to aspect-oriented programming, &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; distinguishes between core concerns and cross-cutting concerns.&lt;/p&gt;
&lt;p&gt;Core concerns are the aspects of the code that fulfill its main goal. We consider as core concerns of a simulation code the aspects handled in the main loop that generate elements needed as input of the next iteration of the loop.&lt;/p&gt;
&lt;p&gt;Cross-cutting concerns are the aspect of the code that are not core concerns. We consider as cross-cutting concerns of a simulation code:&lt;/p&gt;
&lt;p&gt;the aspects handled before the simulation main loop such as parameters reading, data initialization, etc, the aspects handled after the simulation main loop, such as result post-processing, storage to disk, visualization, etc, the aspects handled during the simulation main loop, but whose execution is not required for the next iteration of the loop, such as fault tolerance, logging, etc. The simulation could run with none of the cross-cutting concerns implemented (even if this would be completely useless with no result ever saved). The deactivation of a core concern on the other hand would lead to a failure of the simulation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; supports calling libraries from the specification tree instead of from the code. This is well suited for cross-cutting concerns but means that the code has no control over what and how these aspects are handled which does not fit the needs of core concerns.&lt;/p&gt;
&lt;h2 id=&#34;pdi-description&#34;&gt;PDI description&lt;/h2&gt;
&lt;p&gt;PDI offers to exchange data between the application code and various external data handlers, such as for example the file-system for I/O or another code for code-coupling.&lt;/p&gt;
&lt;p&gt;Before using PDI, it is however a good idea to understand the three core concepts that make this possible.&lt;/p&gt;
&lt;p&gt;Each data exchange is a two-step process. The PDI-enabled application makes its data available through the &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;data store&lt;/a&gt;. The &lt;a href=&#34;member:Concepts_1Event_subsystem&#34;&gt;event subsystem&lt;/a&gt; then notifies interested external data handlers about this change in the store. Once notified, each data handler (implemented as a plugin) can look in the store and use the data accessible from there.&lt;/p&gt;
&lt;p&gt;The orchestration of these exchanges, the description of what data can be put in the store, what each handler should do with it, etc. is described in the &lt;a href=&#34;member:Concepts_1Specification_tree&#34;&gt;specification tree&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_schema.jpg&#34; alt=&#34;PDI structure schema&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;data-store&#34;&gt;Data store&lt;/h2&gt;
&lt;p&gt;The data store is the mechanism offered by PDI to handle &lt;em&gt;data transfer&lt;/em&gt; between the application code and external data handlers. Data transfer is the action of making data available to another part of the code. For example, in a function call the list of parameters determines data transfer.&lt;/p&gt;
&lt;p&gt;PDI data store is somewhat similar to a file-system or a document store with some specific properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unlike in traditional file-systems, data stored in PDI store is typed, one can differentiate between a record with named members and an array for example;&lt;/li&gt;
&lt;li&gt;each process contains a distinct instance of the store, inter-process communications might be offered by data handlers accessing objects in the store and exchanging them between process boundaries, but not by PDI itself;&lt;/li&gt;
&lt;li&gt;storing an object in PDI store is cheap as it does not triggers any copy, instead the store holds a reference to the exact same object in memory as that manipulated by the code;&lt;/li&gt;
&lt;li&gt;to prevent invalid concurrent accesses to the objects, the stores offers a mutual exclusion mechanism where only one handler can access the object for write but concurrent read access is possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This approach makes it possible to exchange data between very weakly coupled code modules. Each module can add or access objects in the store and does not need to know which other module created it or how.&lt;/p&gt;
&lt;p&gt;In summary, the store hold a set of object references, each identified by a name and that contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the address of the buffer storing the data (a pointer),&lt;/li&gt;
&lt;li&gt;the description of the type of the data (memory layout and interpretation),&lt;/li&gt;
&lt;li&gt;a RW-lock to ensure exclusive access.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;event-subsystem&#34;&gt;Event subsystem&lt;/h2&gt;
&lt;p&gt;While the &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;data store&lt;/a&gt; handles data transfer between the application code and external data handlers, the event subsystem handles &lt;em&gt;control&lt;/em&gt; transfer. Control transfer is the action of passing the CPU control to another part of the code. For example, calling a function is a way to transfer control, creating a thread is another way.&lt;/p&gt;
&lt;p&gt;The event subsystem makes it possible to observe the store and to be notified when it is accessed; thus complementing the store with a way for data handler to implement their expected behavior. Notifications are emitted when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a reference becomes available in the store,&lt;/li&gt;
&lt;li&gt;a reference ceases to be available in the store,&lt;/li&gt;
&lt;li&gt;someone accesses a reference that is not in the store,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:group__annotation_1gab21d59fd8d6532f6b8d7a4ac69a2388b&#34;&gt;named event&lt;/a&gt; is emitted.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To ensure minimal overhead, the PDI event subsystem is synchronous by default (like a function call). Plugins can implement other behaviors on top of that. For example, a plugin could create a thread for asynchronous execution.&lt;/p&gt;
&lt;p&gt;This approach makes it possible to exchange data between very weakly coupled code modules. Each module can execute specific code when the required data becomes available and does not need to know which other module created it or how.&lt;/p&gt;
&lt;h2 id=&#34;specification-tree&#34;&gt;Specification tree&lt;/h2&gt;
&lt;p&gt;The combination of data transfer offered by the &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;data store&lt;/a&gt; and control transfer offered by the &lt;a href=&#34;member:Concepts_1Event_subsystem&#34;&gt;event subsystem&lt;/a&gt; offers the basis for weak coupling of multiple independent modules. The specification tree builds on this basis and orchestrates the interaction between the multiple modules used in an execution.&lt;/p&gt;
&lt;p&gt;The specification tree is specified in a file written in the &lt;a href=&#34;https://en.wikipedia.org/wiki/YAML&#34;&gt;YAML&lt;/a&gt; format and provided to PDI at &lt;a href=&#34;member:group__init__final_1ga3dc660be40c93c169337e3d2692b2ed0&#34;&gt;initialization&lt;/a&gt;. This makes it possible to change the list of modules to load and their interactions without having to recompile any code.&lt;/p&gt;
&lt;p&gt;The specification tree structure is described in details in its &lt;a href=&#34;compound:Specification_tree_ref&#34;&gt;reference documentation&lt;/a&gt;. It contains two main subparts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the data types description,&lt;/li&gt;
&lt;li&gt;the plugin list configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The data types description defines the type of data expected in the store. This is most useful for non-reflexive statically typed languages (C, C++, Fortran) for which this information can not be automatically extracted at execution. The types can be expressed in function of the value of other data through &lt;code&gt;$-expressions&lt;/code&gt;. For example, a given object might be described as an array of &lt;code&gt;N&lt;/code&gt; &lt;code&gt;doubles&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is an integer available elsewhere in the store.&lt;/p&gt;
&lt;p&gt;The plugin list configuration defines the list of plugins to load and a configuration for each of them. Each plugin can accept a different way of specifying the configuration, but in any case, this is where the orchestration of interactions is specified. The &lt;a href=&#34;compound:user_code_plugin&#34;&gt;user-code plugin&lt;/a&gt; is somewhat specific in that instead of providing a service itself, it enables the application to react to events and implement specific code handle data from the store.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To summarize, interactions between weakly coupled modules in PDI go through the &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;data store&lt;/a&gt; that acts somewhat like a file-system. One can share data buffers in this store to make them available to other modules. When a buffer becomes available in the store, the &lt;a href=&#34;member:Concepts_1Event_subsystem&#34;&gt;event subsystem&lt;/a&gt; notifies interested modules so that they can use the data. The plugins loaded and configured through the &lt;a href=&#34;member:Concepts_1Specification_tree&#34;&gt;specification tree&lt;/a&gt; offer various reusable services through that mechanism such as data write to disk, fault tolerance, code coupling, etc.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Deprecated List</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/deprecated/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/deprecated/</guid>
      <description>
        
        
        &lt;dl&gt;
&lt;dt&gt;Member &lt;a href=&#34;member:classPDI_1_1Ref__any_1ad3b23b81d198eabcf570e16baa162834&#34;&gt;PDI::Ref_any&amp;lt; R, W &amp;gt;::Ref_any&lt;/a&gt; (Ref other, size_t offset, Datatype_uptr type)&lt;/dt&gt;
&lt;dd&gt;offset/type will be replace by datatype access sequence
Member &lt;a href=&#34;member:group__hl__annotation_1ga39bceccdb0528be91cc79df784a161bc&#34;&gt;PDI_transaction_begin&lt;/a&gt; (const char *name)&lt;/dd&gt;
&lt;dd&gt;the transaction part of the API is deprecated, the PDI_multi_expose function should be used instead.
Member &lt;a href=&#34;member:group__hl__annotation_1gac11c4c2885e34660a40f789f049d3d34&#34;&gt;PDI_transaction_end&lt;/a&gt; (void)&lt;/dd&gt;
&lt;dd&gt;the transaction part of the API is deprecated, the PDI_multi_expose function should be used instead.&lt;/dd&gt;
&lt;/dl&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: First steps with PDI</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/first_steps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/first_steps/</guid>
      <description>
        
        
        &lt;h2 id=&#34;yaml-language&#34;&gt;Yaml language&lt;/h2&gt;
&lt;p&gt;Yaml is used to create the specification tree of PDI. There are 3 basic values in yaml:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scalar - is a single value.&lt;/li&gt;
&lt;li&gt;List - is an array of values.&lt;/li&gt;
&lt;li&gt;Map - consist of mulitple keys and values.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Indentation level indicates the level in the tree.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tree_1:
  array_1:
    - scalar_1
    - scalar_2
  array_2: [1, 2, 3]
tree_2: {subtree_1: scalar_1, subtree_2: scalar_2}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/yaml_example.jpg&#34; alt=&#34;Visualization of the yaml tree\.&#34;&gt;&lt;/p&gt;
&lt;p&gt;The blue nodes are map values, yellow are lists and pink are scalars. As can be seen, the list and map can be defined in both ways (in one line and multiple lines).&lt;/p&gt;
&lt;p&gt;The PDI_init function gets as parameter a tree with &lt;code&gt;logging&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;metadata&lt;/code&gt; and &lt;code&gt;plugins&lt;/code&gt; maps defined in its root. User can define its own values in yaml and pass to PDI only the subtree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;duration: 0.75
size: [64, 64]
parallelism: { height: 4, width: 4 }

# only the following config will be passed to PDI
pdi_subtree:
  metadata:
    iteration:   int
  data:
    main_field: double
  plugins:
    decl_hdf5:
       ...
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;PC_tree_t root = PC_parse_path(&amp;quot;example.yaml&amp;quot;);
PDI_init(PC_get(root, &amp;quot;pdi_subtree&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;hello-event&#34;&gt;Hello Event&lt;/h2&gt;
&lt;p&gt;As mentioned in &lt;a href=&#34;member:Concepts_1Specification_tree&#34;&gt;Specification tree&lt;/a&gt; we have to provide specification tree to instruct PDI what data we will share and what to do with it. We want to show what happens on each PDI API call. We will use &lt;a href=&#34;compound:trace_plugin&#34;&gt;Trace plugin&lt;/a&gt;, which is very simple plugin that just prints every information it gets. Let&#39;s create a specification tree named &lt;code&gt;hello_event.yml&lt;/code&gt; that will load trace plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  trace: ~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Yes, that is whole specification tree. Trace plugin prints everything, so there is no need to specify what we want it to do.&lt;/p&gt;
&lt;p&gt;We need to write a source code of our application:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi.h&amp;gt;

int main(int argc, char* argv[]) {
    PDI_init(PC_parse_path(&amp;quot;hello_event.yml&amp;quot;));
    PDI_event(&amp;quot;Hello World Event&amp;quot;);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&#39;s analyze what happens in each line. Firstly we have &lt;a href=&#34;member:group__init__final_1ga3dc660be40c93c169337e3d2692b2ed0&#34;&gt;PDI_init()&lt;/a&gt; function which take parameter of type &lt;code&gt;PC_tree_t&lt;/code&gt;. It&#39;s a tree structure parsed from some YAML file, in our case we parse it with &lt;code&gt;paraconf&lt;/code&gt; library build in PDI. To parse a file we need to call &lt;code&gt;PC_parse_path&lt;/code&gt; function passing file path as argument. The next step is to call an event in PDI named &amp;quot;Hello World Event&amp;quot;. At the end we have to call &lt;a href=&#34;member:group__init__final_1ga7995fbda2099950ed4ffc7fd4c0bb969&#34;&gt;PDI_finalize()&lt;/a&gt;. The output from this program is presented below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][Trace-plugin][10:25:28] *** info: Welcome!
[PDI][10:25:28] *** info: Initialization successful
[PDI][Trace-plugin][10:25:28] *** info: !!! named event: Hello World Event
[PDI][10:25:28] *** info: Finalization
[PDI][Trace-plugin][10:25:28] *** info: Goodbye!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first line indicates that plugin has loaded successfully. The second is PDI message, that tells it managed to create all descriptors and load all defined plugins. Then we have message from loaded trace plugin which printed the event name it has received. The next information is from PDI and indicates that finalization has started and now it will deallocate resources. Last message is from trace plugin destructor.&lt;/p&gt;
&lt;h3 id=&#34;hello-data&#34;&gt;Hello Data&lt;/h3&gt;
&lt;p&gt;In &lt;a href=&#34;member:First_steps_1fs_hello_event&#34;&gt;Hello Event&lt;/a&gt; we learned how to call an event. In this chapter we will see how to share and reclaim data.&lt;/p&gt;
&lt;p&gt;Firstly we have to create a specification tree named &lt;code&gt;hello_data.yml&lt;/code&gt; with &lt;code&gt;data&lt;/code&gt; and trace plugin tree declared:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  world: int
plugins:
  trace: ~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have declared trace plugin and one descriptor named &lt;code&gt;world&lt;/code&gt; of integer type. Now let&#39;s write our program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi.h&amp;gt;

int main(int argc, char* argv[]) {
    PDI_init(PC_parse_path(&amp;quot;hello_data.yml&amp;quot;));
    int my_world = 42;
    PDI_share(&amp;quot;world&amp;quot;, &amp;amp;my_world, PDI_OUT);
    //variable my_world is shared with PDI

    PDI_reclaim(&amp;quot;world&amp;quot;);
    //variable my_world is no longer shared with PDI

    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&#39;s analyze new functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PDI_share&lt;/code&gt; shares access to the variable with PDI. The first argument is a descriptor name and indicates what data we are sharing. The second one is pointer to our variable and the last one is access direction. &lt;code&gt;PDI_OUT&lt;/code&gt; means data direction from application to PDI, &lt;code&gt;PDI_IN&lt;/code&gt; is a direction from PDI to the program, &lt;code&gt;PDI_INOUT&lt;/code&gt; includes both directions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PDI_reclaim&lt;/code&gt; reclaims the share which means that PDI will no longer have access to shared variable. As an argument it takes name of the descriptor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The output from our application:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][Trace-plugin][10:59:35] *** info: Welcome!
[PDI][10:59:35] *** info: Initialization successful
[PDI][Trace-plugin][10:59:35] *** info: =&amp;gt;&amp;gt;   data becoming available in the store: world
[PDI][Trace-plugin][10:59:35] *** info: &amp;lt;&amp;lt;= data stop being available in the store: world
[PDI][10:59:35] *** info: Finalization
[PDI][Trace-plugin][10:59:35] *** info: Goodbye!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As we can see from the logs above, when we called &lt;code&gt;PDI_share&lt;/code&gt; plugin gained access to the shared variable and after &lt;code&gt;PDI_reclaim&lt;/code&gt; the variable has become no longer available for the plugin. The share notification gives plugin possibility to operate on data dependently what has been declared in specification tree.&lt;/p&gt;
&lt;p&gt;The same exact result we can achieve with &lt;code&gt;PDI_expose&lt;/code&gt; which is just &lt;code&gt;PDI_share&lt;/code&gt; call and right after &lt;code&gt;PDI_reclaim&lt;/code&gt; is called.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_share(&amp;quot;world&amp;quot;, &amp;amp;my_world, PDI_OUT);
PDI_reclaim(&amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is the same as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_expose(&amp;quot;world&amp;quot;, &amp;amp;my_world, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hello-access&#34;&gt;Hello Access&lt;/h3&gt;
&lt;p&gt;Now we will try to access a descriptor we share with PDI. In this case we won&#39;t need any plugin. We want to define string in our &lt;code&gt;world_access.yml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  my_message: {type: array, subtype: char, size: 32}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&#39;s write some simple program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi.h&amp;gt;

void print_secret_msg() {
    char* message;
    PDI_access(&amp;quot;my_message&amp;quot;, (void**)&amp;amp;message, PDI_IN);
    printf(&amp;quot;%s\n&amp;quot;, message);
    PDI_release(&amp;quot;my_message&amp;quot;);
}

int main(int argc, char* argv[]) {
    PDI_init(PC_parse_path(&amp;quot;world_access.yml&amp;quot;));
    char* secret_msg = &amp;quot;Watermelon is the tastiest fruit&amp;quot;;
    PDI_share(&amp;quot;my_message&amp;quot;, secret_msg, PDI_OUT);

    print_secret_msg();

    PDI_reclaim(&amp;quot;my_message&amp;quot;);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will focus on &lt;code&gt;print_secret_msg&lt;/code&gt; function. If you don&#39;t understand what happens in &lt;code&gt;main&lt;/code&gt; function, please see &lt;a href=&#34;member:First_steps_1fs_hello_data&#34;&gt;Hello Data&lt;/a&gt; example. &lt;code&gt;PDI_access&lt;/code&gt; sets our pointer to the data location. We need to pass &lt;code&gt;PDI_IN&lt;/code&gt; because data flows from PDI to our application. We also want to use &lt;code&gt;PDI_release&lt;/code&gt;, because &lt;code&gt;PDI_reclaim&lt;/code&gt; would end the sharing status of this descriptor and we reclaim this data later in &lt;code&gt;main&lt;/code&gt; function. Output from the program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][13:42:31] *** info: Initialization successful
Watermelon is the tastiest fruit
[PDI][13:42:31] *** info: Finalization
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, we manage to access data descriptor from function only by passing its name and correct direction access.&lt;/p&gt;
&lt;h3 id=&#34;hello-multi-expose&#34;&gt;Hello multi expose&lt;/h3&gt;
&lt;p&gt;In some cases we would want to expose many descriptors at once. For this we have multi expose which shares all the given descriptors, then call given event and then reclaim all passed data. Let&#39;s look at the example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  my_int: int
  my_float: float
  my_string: {type: array, subtype: char, size: 32}

plugin:
  trace: ~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have defined 3 descriptors and trace plugin. Now it&#39;s time for our application:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi.h&amp;gt;

int main(int argc, char* argv[]) {
    PDI_init(PC_parse_path(&amp;quot;hello_multi_expose.yml&amp;quot;));
    int x = 0;
    float y = 0;
    char* z = &amp;quot;RGB = Really Gawky Biscuit&amp;quot;;

    PDI_multi_expose(&amp;quot;event_between&amp;quot;,
                     &amp;quot;my_int&amp;quot;, &amp;amp;x, PDI_OUT,
                     &amp;quot;my_float&amp;quot;, &amp;amp;y, PDI_OUT,
                     &amp;quot;my_string&amp;quot;, &amp;amp;z, PDI_OUT,
                     NULL);

    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;First argument of the &lt;code&gt;PDI_multi_expose&lt;/code&gt; is the event name we want to call when all the descriptors are shared. After this we pass in loop:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name of the descriptor&lt;/li&gt;
&lt;li&gt;pointer to the data&lt;/li&gt;
&lt;li&gt;direction access As the last argument we have to pass &lt;code&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The output of the execution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][Trace-plugin][14:14:51] *** info: Welcome!
[PDI][14:14:51] *** info: Initialization successful
[PDI][Trace-plugin][14:14:51] *** info: =&amp;gt;&amp;gt;   data becoming available in the store: my_int
[PDI][Trace-plugin][14:14:51] *** info: =&amp;gt;&amp;gt;   data becoming available in the store: my_float
[PDI][Trace-plugin][14:14:51] *** info: =&amp;gt;&amp;gt;   data becoming available in the store: my_string
[PDI][Trace-plugin][14:14:51] *** info: !!!                            named event: event_between
[PDI][Trace-plugin][14:14:51] *** info: &amp;lt;&amp;lt;= data stop being available in the store: my_string
[PDI][Trace-plugin][14:14:51] *** info: &amp;lt;&amp;lt;= data stop being available in the store: my_float
[PDI][Trace-plugin][14:14:51] *** info: &amp;lt;&amp;lt;= data stop being available in the store: my_int
[PDI][14:14:51] *** info: Finalization
[PDI][Trace-plugin][14:14:51] *** info: Goodbye!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The logs from trace plugin confirm the execution order we were expecting.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FTI plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/fti_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/fti_plugin/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; This documentation is a work in progress and does not reflect the full FTI plugin potential.&lt;/p&gt;
&lt;p&gt;The FTI plugin enables one to perform checkpoints using FTI. FTI plugin does not support the full FTI feature set but offers a simple declarative interface to access a large subset of it.&lt;/p&gt;
&lt;h3 id=&#34;features-and-requirements&#34;&gt;Features and requirements&lt;/h3&gt;
&lt;h4 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h4&gt;
&lt;p&gt;FTI plugin uses a &lt;code&gt;MPI_Comm&lt;/code&gt; datatype and &lt;code&gt;MPI_COMM_WORLD&lt;/code&gt; descriptor, which are defined in &lt;code&gt;mpi&lt;/code&gt; plugin. For now it must be loaded alongside FTI plugin (as shown below).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdi:
   ...

   plugins:
      mpi:
      fti:
         ...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;initialization&#34;&gt;Initialization&lt;/h4&gt;
&lt;p&gt;FTI initialization in FTI plugin is based on several rules.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if &lt;code&gt;init_on&lt;/code&gt; is specified, FTI plugin will initialize FTI on that exact event and expects the communicator and file name to be correctly available or fail otherwise,&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;init_on&lt;/code&gt; is not specified and the communicator isavailable on plugin initialization (e.g. when using &lt;code&gt;MPI_COMM_WORLD&lt;/code&gt; predefine from &lt;code&gt;mpi&lt;/code&gt; plugin), FTI plugin will try to initialize FTI (on plugin initialization) and expects file name to be correctly available or fail otherwise,&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;init_on&lt;/code&gt; is not specified and the communicator is not available on plugin initialization, FTI plugin will try to initialize FTI on communicators descriptor exposure and expects file name to be correctly available or fail otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;predefined-descriptors&#34;&gt;Predefined descriptors&lt;/h4&gt;
&lt;p&gt;FTI plugin loads a predefined descriptor named &lt;code&gt;FTI_COMM_WORLD&lt;/code&gt; (&lt;code&gt;FTI_COMM_WORLD_F&lt;/code&gt; for Fortran) after a successfull initialization of FTI. This descriptor is treated asmetadata. Its content can be accessed using &lt;code&gt;PDI_access&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;configuration-grammar&#34;&gt;Configuration grammar&lt;/h3&gt;
&lt;p&gt;At its root, the FTI configuration is made of several nodes: &lt;code&gt;checkpoint&lt;/code&gt;, &lt;code&gt;communicator&lt;/code&gt;, &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;dataset&lt;/code&gt;, &lt;code&gt;init_on&lt;/code&gt;, &lt;code&gt;recover_on&lt;/code&gt;, &lt;code&gt;recover_var&lt;/code&gt;, &lt;code&gt;send_file&lt;/code&gt;, &lt;code&gt;snapshot_on&lt;/code&gt; and &lt;code&gt;status&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;ttcheckpointtt&#34;&gt;&amp;lt;tt&amp;gt;checkpoint&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;checkpoint&lt;/code&gt; specifies a list of checkpoints to execute. It is specified by a key/value map that may contain following keys: &lt;code&gt;L1_on&lt;/code&gt;, &lt;code&gt;L2_on&lt;/code&gt;, &lt;code&gt;L3_on&lt;/code&gt;, &lt;code&gt;L4_on&lt;/code&gt;. Each of the keys specifies events names that trigger a specified checkpoint. Value of this key can be either string or a list of strings.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L1_on&lt;/code&gt;: executes FTI L1 checkpoint on specified &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L2_on&lt;/code&gt;: executes FTI L2 checkpoint on specified &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L3_on&lt;/code&gt;: executes FTI L3 checkpoint on specified &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L4_on&lt;/code&gt;: executes FTI L4 checkpoint on specified &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ttcommunicatortt&#34;&gt;&amp;lt;tt&amp;gt;communicator&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;communicator&lt;/code&gt; is a string, which specifies name of descriptor containing a MPI communicator to use for FTI initialization. Additionaly, FTI plugin can write &lt;code&gt;FTI_COMM_WORLD&lt;/code&gt; into this descriptor, if it is shared with write access right. It defaults to &lt;code&gt;MPI_COMM_WORLD&lt;/code&gt;, which is a predefined descriptor from &lt;code&gt;mpi&lt;/code&gt; plugin.&lt;/p&gt;
&lt;h4 id=&#34;ttconfig_filett&#34;&gt;&amp;lt;tt&amp;gt;config_file&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;config_file&lt;/code&gt; is a string that can contain $-expressions. Specifies the name of the FTI configuration file.&lt;/p&gt;
&lt;h4 id=&#34;ttdatasettt&#34;&gt;&amp;lt;tt&amp;gt;dataset&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;dataset&lt;/code&gt; is a key/value map, which keys are integers that specify datasets ids in FTI and values are names of protected descriptors. Alternatively, the map may contain a map with keys &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is a name of protected descriptor and &lt;code&gt;size&lt;/code&gt; is a descriptor where FTI plugin will write size of the protected descriptor when shared with write access right.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dataset:
  0: {name: variable, size: variable_size}
  1: variable2
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;ttinit_ontt&#34;&gt;&amp;lt;tt&amp;gt;init_on&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;init_on&lt;/code&gt; is a string or a list of strings that specifies the names of the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events that executes recovery of FTI.&lt;/p&gt;
&lt;h4 id=&#34;ttrecover_ontt&#34;&gt;&amp;lt;tt&amp;gt;recover_on&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;recover_on&lt;/code&gt; is a string or a list of strings that specifies the names of the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events that executes recovery of FTI.&lt;/p&gt;
&lt;h4 id=&#34;ttrecover_vartt&#34;&gt;&amp;lt;tt&amp;gt;recover_var&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; This feature is not yet supported.&lt;/p&gt;
&lt;h4 id=&#34;ttsend_filett&#34;&gt;&amp;lt;tt&amp;gt;send_file&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; This feature is not yet supported. A &lt;code&gt;send_file&lt;/code&gt; is a key/value map or a list of key/value maps describing source and destination paths of files to send, event or list of events to trigger on and optionally name of descriptor, where will be stored status information when exposed. Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;send_file:
  on_even: event
  file:
    src: source_path
    dest: destination_path
    status: status_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;ttsnapshot_ontt&#34;&gt;&amp;lt;tt&amp;gt;snapshot_on&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;snapshot_on&lt;/code&gt; is a string or a list of strings that specifies the names of the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; events that executes FTI_Snapshot.&lt;/p&gt;
&lt;h4 id=&#34;ttstatustt&#34;&gt;&amp;lt;tt&amp;gt;status&amp;lt;/tt&amp;gt;&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;status&lt;/code&gt; is a string that specifies the name of a descriptor to which FTI will write FTI_Status code when shared.&lt;/p&gt;
&lt;h3 id=&#34;full-configuration-example&#34;&gt;full configuration example&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pdi:
  metadata: # type of small values for which PDI keeps a copy
    iter: int
    size:  { size: 2, type: int }
  data: # type of values for which PDI does not keep a copy
    fti_status: int
    array_size: int64
    file_name: {size: 64, type: array, subtype: char}
    file_status: int
    file1_status: int
    file2_status: int
    main_array: { size: [&#39;$size[0]&#39;, &#39;$size[1]&#39;], type: array, subtype: double }

  plugins:
    mpi:
    fti:
      config_file: fti_config.ini
      communicator: MPI_COMM_WORLD
      init_on: fti_init_event
      status: fti_status
      dataset:
        0: {name: main_array, size: array_size}
        1: iter
      snapshot_on: snapshot_event
      recover_on: recover_event
      checkpoint:
        L1_on: ckpt_l1_event
        L2_on: [ckpt_l2_1_event, ckpt_l2_2_event]
        L3_on: [ckpt_l3_1_event, ckpt_l3_2_event]
        L4_on: ckpt_l4_event
      send_file:
        - on_event: send_one_file
          file:
            src: ./$file_name
            dest: ./somewhere_else/$file_name
            status: file_status
        - on_event: [send_two_files_first_event, send_two_files_second_event]
          file:
            - src: ./file1
              dest: ./somewhere_else/file1
              status: file1_status
            - src: ./file2
              dest: ./somewhere_else/file2
              status: file2_status
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Hands-on tutorial</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/hands_on/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/hands_on/</guid>
      <description>
        
        
        &lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    You need to &lt;a href=&#34;Installation.html&#34;&gt;install&lt;/a&gt; PDI before proceeding with this tutorial.

&lt;/div&gt;

&lt;p&gt;After PDI &lt;a href=&#34;Installation.html&#34;&gt;is installed&lt;/a&gt;, you can proceed with getting the sources for the hands-on tutorial from &lt;a href=&#34;https://github.com/pdidev/tutorial&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/pdidev/tutorial.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before compilation, configure the tutorial by detecting all dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd tutorial
pdirun cmake .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you&#39;re ready to work, &lt;strong&gt;good luck&lt;/strong&gt;!&lt;/p&gt;
&lt;h2 id=&#34;tutorial&#34;&gt;Tutorial&lt;/h2&gt;
&lt;p&gt;For each exercise, once you&#39;ve modified it, you can compile it by running the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ex4. Writing some real data
make ex?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where &lt;code&gt;?&lt;/code&gt; is the number of the exercise.&lt;/p&gt;
&lt;p&gt;Then, you can run it with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdirun mpirun -n 1 ./ex?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where &lt;code&gt;?&lt;/code&gt; is again the number of the exercise.&lt;/p&gt;
&lt;h3 id=&#34;ex1-getting-started&#34;&gt;Ex1. Getting started&lt;/h3&gt;
&lt;p&gt;Ex1. implements a simple heat equation solver using an explicit forward finite difference scheme parallelized with MPI as described in the &lt;a href=&#34;PDI_example.html&#34;&gt;PDI example&lt;/a&gt;. If you want to better understand what&#39;s going on, you should read this description before continuing.&lt;/p&gt;
&lt;p&gt;In the exercises however, PDI will only be used to decouple I/O operations. There is no need to fully dive in the core of the solver implemented in the &lt;code&gt;iter&lt;/code&gt; and &lt;code&gt;exchange&lt;/code&gt; functions. The specification tree in the &lt;code&gt;.yml&lt;/code&gt; files and the &lt;code&gt;main&lt;/code&gt; function are the locations where all the I/O-related aspects will be handled and the only ones you will actually need to fully understand or modify.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Examine the source code, compile it and run it. There is no input/output operations in the code yet, so you can not see any result.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This example uses the &lt;a href=&#34;https://github.com/pdidev/paraconf&#34;&gt;paraconf library&lt;/a&gt; to read its parameters in &lt;a href=&#34;https://yaml.org&#34;&gt;yaml format&lt;/a&gt; from the &lt;code&gt;ex1.yml&lt;/code&gt; file. If you&#39;ve never heard about yaml, have a quick look at &lt;a href=&#34;First_steps.html#Yaml&#34;&gt;this example&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Play with and understand the code parameters in &lt;code&gt;ex1.yml&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Set values in &lt;code&gt;ex1.yml&lt;/code&gt; to be able to run the code with 3 MPI processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ex2-now-with-some-pdi&#34;&gt;Ex2. Now with some PDI&lt;/h3&gt;
&lt;p&gt;Ex2. is the same code as ex1. with PDI calls added in main function. The PDI &lt;a href=&#34;tra%60PDIce_plugin.html&#34;&gt;Trace plugin&lt;/a&gt; is used to trace PDI calls.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add the required &lt;code&gt;PDI_share&lt;/code&gt; and &lt;code&gt;PDI_reclaim&lt;/code&gt; calls to match the output of &lt;code&gt;ex2.log&lt;/code&gt; file. Change only the &lt;code&gt;ex2.c&lt;/code&gt; file. The calls for now don&#39;t need to make any logic, just match output to the &lt;code&gt;ex2.log&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    Notice that some share/reclaim pairs come one after the other while others are interlaced. Is one better than the other? If you do not know the answer to this question, please wait until Ex5. :)

&lt;/div&gt;

&lt;h3 id=&#34;ex3-hdf5-through-pdi&#34;&gt;Ex3. HDF5 through PDI&lt;/h3&gt;
&lt;p&gt;Let&#39;s take the code from ex2. and make it output some HDF5 data. No need to touch the C code here, the PDI yaml file should be enough. The &lt;a href=&#34;trace_plugin.html&#34;&gt;Trace plugin&lt;/a&gt; was replaced by the &lt;a href=&#34;Decl_HDF5_plugin.html&#34;&gt;Dec&#39;HDF5 plugin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fill 2 sections in the yaml file:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;data&lt;/code&gt; section to indicate to PDI the type of the fields that are exposed.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;decl_hdf5&lt;/code&gt; for the configuration of &lt;a href=&#34;Decl_HDF5_plugin.html&#34;&gt;Dec&#39;HDF5 plugin&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Only &lt;code&gt;dsize&lt;/code&gt; is written as of now, let&#39;s add &lt;code&gt;psize&lt;/code&gt; and &lt;code&gt;pcoord&lt;/code&gt; to match the content expected described in &lt;code&gt;ex3.href 5dump&lt;/code&gt; (use &lt;code&gt;h5dump&lt;/code&gt; command to see content of HDF5 file).&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    If you rerun the exercise, remember to delete your old &lt;code&gt;ex3.h5&lt;/code&gt; file, because the data will not be overwritten.

&lt;/div&gt;

&lt;h3 id=&#34;ex4-writing-some-real-data&#34;&gt;Ex4. Writing some real data&lt;/h3&gt;
&lt;p&gt;In this exercise each MPI process will write its local matrix to separete HDF5 files. Touch only the yaml file again.&lt;/p&gt;
&lt;p&gt;This time write the real 2D data contained in &lt;code&gt;main_field&lt;/code&gt; using 2 MPI processes.&lt;/p&gt;
&lt;p&gt;Notice that a list to write multiple files was used in the decl_hdf5 section instead of a single mapping as before.&lt;/p&gt;
&lt;p&gt;Unlike the other fields manipulated until now, the type of &lt;code&gt;main_field&lt;/code&gt; is not fully known, its size is dynamic. By moving other fields in the &lt;code&gt;metadata&lt;/code&gt; section, you can reference them from &amp;quot;$ expressions&amp;quot; in the configuration file. This can be used to specify a dynamic size for &lt;code&gt;main_field&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unlike the other fields manipulated until now, &lt;code&gt;main_field&lt;/code&gt; is exposed multiple times. In order not to overwrite it every time it is exposed, you can add a &lt;code&gt;when&lt;/code&gt; condition to restrict its output. Only write &lt;code&gt;main_field&lt;/code&gt; at the second iteration (when &lt;code&gt;ii==1&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Set the parallelism degree to 2 in height and try to match the expected content described in &lt;code&gt;ex4.h5dump&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;ex5-introducing-events&#34;&gt;Ex5. Introducing events&lt;/h3&gt;
&lt;p&gt;In ex4, there were 2 pieces of data to &lt;code&gt;ex4-data*.h5&lt;/code&gt;, but the file is opened and closed for each and every write. Since Decl&#39;HDF5 only sees the data appear one after the other, it does not keep the file open. Since &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;main_field&lt;/code&gt; are shared in an interlaced way, they are both available at the same time and could be written without opening the file twice. You have to use events for that.&lt;/p&gt;
&lt;p&gt;There are 3 main tasks in this exercise:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Call PDI event named &lt;code&gt;loop&lt;/code&gt; when both &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;main_field&lt;/code&gt; are shared. With the &lt;a href=&#34;trace_plugin.html&#34;&gt;Trace plugin&lt;/a&gt;, check that the event is indeed triggered at the expected time as described in &lt;code&gt;ex5.log&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;on_event&lt;/code&gt; mechanism to trigger the write of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;main_field&lt;/code&gt;. This mechanism can be combined with a &lt;code&gt;when&lt;/code&gt; directive, in that case the write is only executed when both mechanisms agree.&lt;/li&gt;
&lt;li&gt;Also notice the extended syntax that make it possible to write data to a dataset with a name different from the data in PDI. Use this mechanism to write main_field at iterations 1 and 2, in two distinct groups &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Match the content as expected in &lt;code&gt;ex5.h5dump&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;ex6-simplifying-the-code&#34;&gt;Ex6. Simplifying the code&lt;/h3&gt;
&lt;p&gt;As you can notice, the PDI code is quite redundant. In this exercise, you will use &lt;code&gt;PDI_expose&lt;/code&gt; and &lt;code&gt;PDI_multi_expose&lt;/code&gt; to simplify the code while keeping the exact same behaviour.&lt;/p&gt;
&lt;p&gt;There are lots of matched &lt;code&gt;PDI_share&lt;/code&gt;/&lt;code&gt;PDI_reclaim&lt;/code&gt; in the code. Replace these by &lt;code&gt;PDI_expose&lt;/code&gt; that is the exact equivalent of a &lt;code&gt;PDI_share&lt;/code&gt; followed by a matching &lt;code&gt;PDI_reclaim&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This replacement is not possible for interlaced &lt;code&gt;PDI_share&lt;/code&gt;/&lt;code&gt;PDI_reclaim&lt;/code&gt; with events in the middle. This case is however handled by &lt;code&gt;PDI_multi_expose&lt;/code&gt; call that exposes all data, then triggers an event and finally does all the reclaim in reverse order. Replace the remaining &lt;code&gt;PDI_share&lt;/code&gt;/&lt;code&gt;PDI_reclaim&lt;/code&gt; by &lt;code&gt;PDI_expose&lt;/code&gt;s and &lt;code&gt;PDI_multi_expose&lt;/code&gt;s. There is one &lt;code&gt;PDI_share&lt;/code&gt;/&lt;code&gt;PDI_reclaim&lt;/code&gt; you can not replace.&lt;/p&gt;
&lt;p&gt;Touch only the C file in this exercise.&lt;/p&gt;
&lt;p&gt;Ensure that your code keeps the exact same behaviour by comparing its trace to &lt;code&gt;ex6.log&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;ex7-writing-a-selection&#34;&gt;Ex7. Writing a selection&lt;/h3&gt;
&lt;p&gt;In this exercise, you will only write a selection (part) of the data to the HDF5 file.&lt;/p&gt;
&lt;p&gt;As you can notice, now the dataset is independantly described in the file. Use two directives to specify a selection from the data to write and a selection in the dataset where to write.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;memory_selection&lt;/code&gt; tells what part to take from the data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataset_selection&lt;/code&gt; tells where to write this part of data in file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Restrict the selection to the second line from the data and write it to a one-dimensional dataset in file.&lt;/p&gt;
&lt;p&gt;Touch only the yaml file in this exercise.&lt;/p&gt;
&lt;p&gt;Match the expected output described in &lt;code&gt;ex7.out&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  matrix: {type: array, subtype: int, size: [8,8]}

...
    datasets:
      matrix: {type: array, subtype: int, size: 8}
...
        memory_selection:
          size: [1, 8]
          start: [4, 0]
        dataset_selection:
          size: 8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The graphical representation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ex8-writing-an-advanced-selection&#34;&gt;Ex8. Writing an advanced selection&lt;/h3&gt;
&lt;p&gt;You can also add dimensions, write the 2D array excluding ghosts as a slab of a 3D dataset including a dimension for the time-iteration. Write iterations 1 to 3 inclusive into dimensions 0 to 2.&lt;/p&gt;
&lt;p&gt;Touch only the yaml file in this exercise.&lt;/p&gt;
&lt;p&gt;Match the expected output described in &lt;code&gt;ex8.h5dump&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  matrix: {type: array, subtype: int, size: [8,8]}

...
    datasets:
      matrix: {type: array, subtype: int, size: [3, 8, 8]}
...
        memory_selection:
          size: [8, 8]
        dataset_selection:
          size: [1, 8, 8]
          start: [$ii, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the graphical representation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection_advanced.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection_advanced.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection_advanced.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_selection_advanced.jpg&#34; alt=&#34;graphical representation&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ex9-going-parallel&#34;&gt;Ex9. Going parallel&lt;/h3&gt;
&lt;p&gt;Running the current code in parallel should already work and yield one file per process containing the local data block. In this exercise you will write one single file with parallel HDF5 whose content should be independent from the number of processes used.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;mpi plugin&lt;/code&gt; was loaded to make sharing MPI communicators possible.&lt;/p&gt;
&lt;p&gt;There are several tasks in this exercise:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Uncomment the &lt;code&gt;communicator&lt;/code&gt; directive of the &lt;a href=&#34;Decl_HDF5_plugin.html&#34;&gt;Dec&#39;HDF5 plugin&lt;/a&gt; to switch to parallel I/O.&lt;/li&gt;
&lt;li&gt;Change the file name so all processes open the same file.&lt;/li&gt;
&lt;li&gt;Set the size of &lt;code&gt;main_field&lt;/code&gt; in &lt;code&gt;datasets&lt;/code&gt; tree to take the global matrix into account. Hint: use &lt;code&gt;psize&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Ensure the dataset selection of each process does not overlap with the others. Hint: use &lt;code&gt;pcoord&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Try to match the output from &lt;code&gt;ex9.out&lt;/code&gt;, that should be independent from the number of processes used.&lt;/p&gt;
&lt;p&gt;Touch only the yaml file in this exercise.&lt;/p&gt;
&lt;p&gt;Here is graphical representation of the parallel I/O:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_parallel.jpg&#34; alt=&#34;graphical representation of the parallel I\/O&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_parallel.jpg&#34; alt=&#34;graphical representation of the parallel I\/O&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_parallel.jpg&#34; alt=&#34;graphical representation of the parallel I\/O&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/PDI_hdf5_parallel.jpg&#34; alt=&#34;graphical representation of the parallel I\/O&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;what-next-&#34;&gt;What next ?&lt;/h2&gt;
&lt;p&gt;You can experiment with other &lt;a href=&#34;Plugins.html&#34;&gt;plugins&lt;/a&gt;. Have a look at the &lt;a href=&#34;https://gitlab.maisondelasimulation.fr/pdidev/pdi/-/tree/master/example&#34;&gt;PDI examples&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: How to create a plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/how_to_create_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/how_to_create_plugin/</guid>
      <description>
        
        
        &lt;h2 id=&#34;plugin-class&#34;&gt;Plugin class&lt;/h2&gt;
&lt;p&gt;Plugin is a class, that handles shared data and triggered events to perform an I/O operations. It is dynamically linked to the user program by &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt;. Behavior of each plugin is defined by specification tree in plugins subtree.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  example:
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The given example will load example plugin and pass its subtree to the plugin&#39;s constructor.&lt;/p&gt;
&lt;p&gt;The plugin has to inherit from &lt;a href=&#34;compound:classPDI_1_1Plugin&#34;&gt;PDI::Plugin&lt;/a&gt; and have a constructor with arguments &lt;a href=&#34;compound:classPDI_1_1Context&#34;&gt;PDI::Context&lt;/a&gt;&amp;amp; and PC_tree_t.&lt;/p&gt;
&lt;h3 id=&#34;example-plugin&#34;&gt;Example plugin&lt;/h3&gt;
&lt;p&gt;Example of the simplest plugin, that does nothing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {}
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;adding-a-callback&#34;&gt;Adding a callback&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;compound:classPDI_1_1Context&#34;&gt;PDI::Context&lt;/a&gt; has a container with all the functions (callbacks) that are called when user is sharing the data (calls PDI_share). To add a new function to this container the plugin must call add_data_callback.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::function&amp;lt;void()&amp;gt; add_data_callback(const std::function&amp;lt;void(const std::string&amp;amp;, Ref)&amp;gt;&amp;amp; callback, const std::string&amp;amp; name = {}))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first argument is the function to be called when user shares the data. If the second parameter (name) is given, the function will be called only on a specified data name. Returns a function that removes the callback from &lt;a href=&#34;compound:classPDI_1_1Context&#34;&gt;PDI::Context&lt;/a&gt; container.&lt;/p&gt;
&lt;p&gt;Example of adding new callback:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;
#include &amp;lt;pdi/ref_any.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        ctx.add_data_callback([](const std::string&amp;amp; data_name, PDI::Ref ref){
            std::cout &amp;lt;&amp;lt; &amp;quot;User has shared a data named &amp;quot; &amp;lt;&amp;lt; data_name &amp;lt;&amp;lt; std::endl;
        });
    }
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If user create specification tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
    some_integer: int

plugins:
    example: ~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And a program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi.h&amp;gt;

int main()
{
    PDI_init(PC_parse_path(&amp;quot;spec_tree.yaml&amp;quot;));
    int some_integer = 0;
    PDI_expose(&amp;quot;some_integer&amp;quot;, &amp;amp;some_integer, PDI_OUT);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The console will display:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][13:42:41] *** info: Initialization successful
User has shared a data named some_integer
[PDI][13:42:42] *** info: Finalization
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;reading-and-writing-data&#34;&gt;Reading and writing data&lt;/h3&gt;
&lt;p&gt;Example of reading and writing data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;
#include &amp;lt;pdi/ref_any.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        ctx.add_data_callback([](const std::string&amp;amp; data_name, PDI::Ref ref){
            if(PDI::Ref_rw ref_rw{ref}) {
                //Plugin can read and write
                int* some_integer = ref_rw.get();
            } else if(PDI::Ref_r ref_r{ref}) {
                //Plugin can read
                const int* some_integer = ref_r.get();
            } else if(PDI::Ref_w ref_w{ref}) {
                //Plugin can write
                int* some_integer = ref_w.get();
            } else {
                //Plugin cannot read nor write
            }
        });
    }
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;handling-events&#34;&gt;Handling events&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;
#include &amp;lt;pdi/ref_any.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        ctx.add_event_callback([this](const std::string&amp;amp; event_name){
            this-&amp;gt;handle_event(event_name);
        });
        ctx.add_event_callback([this](const std::string&amp;amp; event_name){
            this-&amp;gt;handle_special_event(event_name);
        }, &amp;quot;special_event&amp;quot;);
    }
private:
    void handle_event(const std::string&amp;amp; event_name) {
        std::cout &amp;lt;&amp;lt; &amp;quot;Event&amp;quot; &amp;lt;&amp;lt; event_name &amp;lt;&amp;lt; &amp;quot;called.&amp;quot; &amp;lt;&amp;lt; std::endl;
    }

    void handle_special_event(const std::string&amp;amp; event_name) {
        std::cout &amp;lt;&amp;lt; &amp;quot;Special event `&amp;quot; &amp;lt;&amp;lt; event_name &amp;lt;&amp;lt; &amp;quot;&#39; called.&amp;quot; &amp;lt;&amp;lt; std::endl;
    }
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;reading-scalar-and-array-from-specification-tree&#34;&gt;Reading scalar and array from specification tree&lt;/h3&gt;
&lt;p&gt;Specification tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  example:
    scalar: some_string
    array: [0, 1, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reading a scalar and an array:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;
#include &amp;lt;pdi/ref_any.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        //scalar
        PC_tree_t scalar_tree = PC_get(spec_tree, &amp;quot;.scalar&amp;quot;);
        std::string string_scalar = PDI::to_string(scalar_tree);

        //array
        PC_tree_t array_tree = PC_get(spec_tree, &amp;quot;.array&amp;quot;);
        int array_size = PDI::len(array_tree);
        std::vector&amp;lt;long&amp;gt; array;
        for (int i = 0; i &amp;lt; array_size; i++) {
            PC_tree_t array_element = PC_get(array_tree, &amp;quot;[%d]&amp;quot;, i);
            array.emplace_back(PDI::to_long(array_element));
        }
    }
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;reading-maps-from-specification-tree&#34;&gt;Reading maps from specification tree&lt;/h3&gt;
&lt;p&gt;Specification tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  example:
    custom_subtree:
        here: 0
        can: 1
        be: 2
        any: 3
        subtree: 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reading a scalar and an array:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unordered_map&amp;gt;

#include &amp;lt;pdi/context.h&amp;gt;
#include &amp;lt;pdi/paraconf_wrapper.h&amp;gt;
#include &amp;lt;pdi/plugin.h&amp;gt;
#include &amp;lt;pdi/ref_any.h&amp;gt;

struct example_plugin : public PDI::Plugin
{
    example_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        PC_tree_t subtree = PC_get(spec_tree, &amp;quot;.custom_subtree&amp;quot;);
        int subtree_size = PDI::len(subtree);
        std::unordered_map&amp;lt;std::string, long&amp;gt; custom_map;

        for (int i = 0; i &amp;lt; subtree_size; i++) {
            PC_tree_t key = PC_get(subtree, &amp;quot;{%d}&amp;quot;, i);
            PC_tree_t value = PC_get(subtree, &amp;quot;&amp;lt;%d&amp;gt;&amp;quot;, i);
            custom_map.emplace_back(PDI::to_string(key), PDI::to_long(value));
        }
    }
}

PDI_PLUGIN(example)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;creating-a-true-plugin-posix-plugin&#34;&gt;Creating a true plugin: POSIX plugin&lt;/h2&gt;
&lt;h3 id=&#34;step-1-think-what-your-plugin-will-be-for&#34;&gt;Step 1: Think what your plugin will be for.&lt;/h3&gt;
&lt;p&gt;Simple checkpointing. Each data will be saved in separate file. User can check the status of all files at once and then recover the data.&lt;/p&gt;
&lt;h3 id=&#34;step-2-prepare-your-specification-tree-schema&#34;&gt;Step 2: Prepare your specification tree schema.&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  some_data: {type: array, subtype: int, size: 64}
  can_recover_data: int

plugins:
  posix:
    data:
      some_data: /file_path/
    can_recover_all: can_recover_data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;/file_path/ is a path where to save and load from some_data. can_recover_data is a flag that indicates if the recover is possible.&lt;/p&gt;
&lt;p&gt;The fastest way to learn is by examples. To show how to create a plugin, we will create &amp;quot;posix plugin&amp;quot;. It won&#39;t do anything special, but give you a basic knowledge how to create one.&lt;/p&gt;
&lt;h3 id=&#34;step-3-write-your-plugin&#34;&gt;Step 3: Write your plugin.&lt;/h3&gt;
&lt;p&gt;Members and constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class posix_plugin : public PDI::Plugin
{
    std::string m_can_recover_data;
    std::unordered_map&amp;lt;std::string, std::string&amp;gt; m_data_to_path_map;

public:
    posix_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {}
}

PDI_PLUGIN(posix)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read recover tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void read_recover_tree(PC_tree_t spec_tree) {
    PC_tree_t recover_tree = PC_get(spec_tree, &amp;quot;.can_recover_all&amp;quot;);
    if(!PC_status(recover_tree)) {
        m_can_recover_data = PDI::to_string(recover_tree);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read data tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void read_data_tree(PC_tree_t spec_tree) {
    PC_tree_t data_tree = PC_get(spec_tree, &amp;quot;.data&amp;quot;);
    if (!PC_status(data_tree)) {
        int data_tree_size = PDI::len(data_tree);
        for (int i = 0; i &amp;lt; data_tree_size; i++) {
            PC_tree_t key = PC_get(data_tree, &amp;quot;{%d}&amp;quot;, i);
            PC_tree_t value = PC_get(data_tree, &amp;quot;&amp;lt;%d&amp;gt;&amp;quot;, i);
            m_data_to_path_map.emplace_back(PDI::to_string(key), PDI::to_string(value));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Create a function that writes data to temporary file and check if file was created, size is correct and then replace old file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void write_data(const std::string&amp;amp; data_name, PDI::Ref_r ref_r) {
    if(!ref_r) {
        return;
    }
    std::string tmp_path = m_data_to_path_map[data_name] + &amp;quot;.tmp&amp;quot;;
    std::ofstream file{tmp_path, std::ios::binary};
    if (ref_r.type().buffersize() == ref_r.type().datasize()) {
        //dense data
        file.write((const char*)ref_r.get(), ref_r.type().buffersize());
    } else {
        //sparse data
        std::unique_ptr&amp;lt;char&amp;gt; data_copy {new char[ref_r.type().dataSize()]};
        ref_r.type().data_to_dense_copy(data_copy.get(), ref_r.get());
        file.write(data_copy.get(), ref_r.type().datasize());
    }
    file.close();

    //replace old file
    struct stat status;
    if (!stat(tmp_path.c_str(), &amp;amp;status) &amp;amp;&amp;amp; status.st_size == ref_r.type().datasize()) {
        if (!stat(m_data_to_path_map[data_name].c_str()) &amp;amp;&amp;amp; std::remove(m_data_to_path_map[data_name].c_str())) {
            throw PDI::Error {PDI_ERR_SYSTEM, &amp;quot;Cannot remove old file {}&amp;quot;, m_data_to_path_map[data_name]};
        }
        if (std::rename(tmp_path.c_str(), m_data_to_path_map[data_name].c_str())) {
            throw PDI::Error {PDI_ERR_SYSTEM, &amp;quot;Cannot rename temporary file {}&amp;quot;, tmp_path};
        }
    } else {
        throw PDI::Error {PDI_ERR_SYSTEM, &amp;quot;Data write not complete&amp;quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Create a function that reads data from file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void read_data(const std::string&amp;amp; data_name, PDI::Ref_w ref_w) {
    if(!ref_w) {
        return;
    }
    std::ifstream file{m_data_to_path_map[data_name], std::ios::binary};
    if (ref_w.type().buffersize() == ref_w.type().datasize()) {
        //dense data
        file.read((char*)ref_w.get(), ref_w.type().buffersize());
    } else {
        //sparse data
        std::unique_ptr&amp;lt;char&amp;gt; data_copy {new char[ref_w.type().dataSize()]};
        file.read(data_copy.get(), ref_w.type().datasize());
        ref_w.type().data_from_dense_copy(ref_w.get(), data_copy.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Handle can_recover_all data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void can_recover(const std::string&amp;amp; data_name, PDI::Ref_w ref_w) {
    if (!ref_w) {
        throw PDI::Error {PDI_ERR_RIGHT, &amp;quot;Cannot write to `can_recover_all&#39; data&amp;quot;};
    }
    for (const auto&amp;amp; data_path_pair : m_data_to_path_map) {
        struct stat status;
        if (stat(data_path_pair.second.c_str(), &amp;amp;status)) {
            *static_cast&amp;lt;int*&amp;gt;(ref_w.get()) = 0;
            return;
        }
    }
    *static_cast&amp;lt;int*&amp;gt;(ref_w.get()) = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Add created functions to callbacks:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class posix_plugin : public PDI::Plugin
{
    std::string m_can_recover_data;
    std::unordered_map&amp;lt;std::string, std::string&amp;gt; m_data_to_path_map;

public:
    posix_plugin(PDI::Context&amp;amp; ctx, PC_tree_t spec_tree):
        Plugin{ctx}
    {
        read_recover_tree(spec_tree);
        read_data_tree(spec_tree);
        for (const auto&amp;amp; data_path_pair : m_data_to_path_map) {
            ctx.add_data_callback([this](const std::string&amp;amp; data_name, PDI::Ref ref) {
                this-&amp;gt;write_data(data_name, ref);
            }, data_path_pair.first);
            ctx.add_data_callback([this](const std::string&amp;amp; data_name, PDI::Ref ref) {
                this-&amp;gt;read_data(data_name, ref);
            }, data_path_pair.first);
        }
        if (!m_can_recover_data.empty()) {
            ctx.add_data_callback([this](const std::string&amp;amp; data_name, PDI::Ref ref) {
                this-&amp;gt;can_recover(data_name, ref);
            }, m_can_recover_all_data);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Compile: g++ posix.cxx -o libpdi_posix_plugin.so -lpdi -shared -fPIC -std=c++11&lt;/li&gt;
&lt;li&gt;Copy created file to path where dynamic linker can find it. For example: sudo cp libpdi_posix_plugin.so /usr/local/lib/&lt;/li&gt;
&lt;li&gt;Configure dynamic linker run-time bindings: sudo ldconfig&lt;/li&gt;
&lt;li&gt;Create program that uses posix plugin.&lt;/li&gt;
&lt;li&gt;Compile your test program: gcc example_use.cxx -o example_use -lpdi -lparaconf&lt;/li&gt;
&lt;li&gt;Run your test program: ./example_use&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can see example of the program that uses this plugin on these &lt;a href=&#34;https://docs.google.com/presentation/d/1jT416oALDkquBBgq_XkVrU48o4qx72wGHUPb4emXJw4&#34;&gt;slides&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Installation of PDI source distribution</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/installation/</guid>
      <description>
        
        
        

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    The recommended approach to install PDI is to use the stable pre-compiled binary packages for Debian, Fedora and Ubuntu available at &lt;a href=&#34;https://github.com/pdidev/pkgs/tree/repo&#34;&gt;https://github.com/pdidev/pkgs/tree/repo&lt;/a&gt; .

&lt;/div&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    On other distributions, in case you do not have root acces, or if you want a more recent version, the &lt;strong&gt;PDI source distribution&lt;/strong&gt; can be easily downloaded and compiled.

&lt;/div&gt;

&lt;p&gt;The PDI source distribution includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the PDI core and its bindings for Fortran and python,&lt;/li&gt;
&lt;li&gt;all PDI plugins,&lt;/li&gt;
&lt;li&gt;the PDI configuration validator,&lt;/li&gt;
&lt;li&gt;examples and tests,&lt;/li&gt;
&lt;li&gt;most dependencies of all the above.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;downloading-pdi-source-distribution&#34;&gt;Downloading PDI source distribution&lt;/h2&gt;
&lt;p&gt;To download the sources, have a look at the list of all releases from: &lt;a href=&#34;https://gitlab.maisondelasimulation.fr/pdidev/pdi/tags&#34;&gt;https://gitlab.maisondelasimulation.fr/pdidev/pdi/tags&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For example, release 0.6.1 can be downloaded by following these instructions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://gitlab.maisondelasimulation.fr/pdidev/pdi/-/archive/0.6.1/pdi-0.6.1.tar.bz2
tar -xjf pdi-0.6.1.tar.bz2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;default-installation&#34;&gt;Default installation&lt;/h2&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    The &lt;em&gt;default PDI source distribution&lt;/em&gt; consists in a subset of the PDI source distribution considered stable enough for production use.

&lt;/div&gt;

&lt;p&gt;Installing the default PDI source distribution is fairly easy. Most dependencies are embedded in the distribution and the only required external dependencies are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cmake.org&#34;&gt;cmake&lt;/a&gt;, version &amp;gt;= 3.5,&lt;/li&gt;
&lt;li&gt;a C 99, C++ 14 and Fortran 95 compiler (&lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;gcc&lt;/a&gt; 5.4 is tested),&lt;/li&gt;
&lt;li&gt;a POSIX compatible OS with a &lt;a href=&#34;https://www.gnu.org/software/bash/&#34;&gt;bash&lt;/a&gt; and &lt;a href=&#34;https://www.python.org/&#34;&gt;python&lt;/a&gt; interpreter (&lt;a href=&#34;https://www.kernel.org/&#34;&gt;linux&lt;/a&gt; with &lt;a href=&#34;https://www.gnu.org/software/libc/&#34;&gt;GNU libc&lt;/a&gt; 2.27 is tested),&lt;/li&gt;
&lt;li&gt;a MPI implementation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, release 0.6.1 can be installed by following these instructions (but look for the latest release at &lt;a href=&#34;https://gitlab.maisondelasimulation.fr/pdidev/pdi/tags&#34;&gt;https://gitlab.maisondelasimulation.fr/pdidev/pdi/tags&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir pdi-0.6.1/build &amp;amp;&amp;amp; cd pdi-0.6.1/build
cmake -DCMAKE_INSTALL_PREFIX=/usr/ ..       # configuration
make install   # compilation and installation
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    The &lt;code&gt;cmake&lt;/code&gt; command must be followed by the path to the &lt;code&gt;pdi&lt;/code&gt; directory, here &lt;code&gt;..&lt;/code&gt; because we have just created and moved to the &lt;code&gt;build&lt;/code&gt; subdirectory.

&lt;/div&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    The &lt;code&gt;-DCMAKE_INSTALL_PREFIX=/usr/&lt;/code&gt; flag is used to specify where to install the distribution, flags are &lt;a href=&#34;member:Installation_1cmake_config&#34;&gt;discussed in more detail below&lt;/a&gt;.

&lt;/div&gt;

&lt;p&gt;If the default installation fails or if you need an installation better tailored to your needs, keep reading.&lt;/p&gt;
&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;The PDI source distribution is compiled using CMake. The &lt;code&gt;cmake&lt;/code&gt; command accepts options to configure the distribution with flags. The syntax is &lt;code&gt;-D&amp;lt;FLAG&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; to set &lt;code&gt;FLAG&lt;/code&gt; value to &lt;code&gt;VALUE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, the installation directory can be changed with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake -DCMAKE_INSTALL_PREFIX=/home/user/ ..
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following general flags are useful to configure the distribution as a whole.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag&lt;/th&gt;
&lt;th&gt;Default&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/usr/local&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The path where to install the distribution.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A semicolon-separated list of prefix where to look for PDI dependencies in addition to system path.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DIST_PROFILE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Sets the default values of other flags. The possible values are &lt;code&gt;User&lt;/code&gt; for the PDI use profile and &lt;code&gt;Devel&lt;/code&gt; for the developer profile.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_DEFAULT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Whether to compile the embedded versions of the dependencies. The possible values are &lt;code&gt;SYSTEM&lt;/code&gt; to use the system versions, &lt;code&gt;EMBEDDED&lt;/code&gt; to compile the version provided in the distribution and &lt;code&gt;AUTO&lt;/code&gt; to prefer a system version but fall-back on the embedded version if unavailable.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_UNSTABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Whether to build the unstable parts of the distribution, either &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;OFF&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CMAKE_BUILD_TYPE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Optimization level and debug verbosity. The possible values are &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The following flags define which features of the distribution to enable or not.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag&lt;/th&gt;
&lt;th&gt;Default&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_FORTRAN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the Fortran interface.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_DECL_HDF5_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the Decl&#39;HDF5 plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_HDF5_PARALLEL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the parallel version of the Decl&#39;HDF5 plugin instead of the sequential one.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_MPI_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the MPI plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_TEST_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the Test plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_TRACE_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the Trace plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_USER_CODE_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the User-code plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_PYTHON&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the Python interface.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_DECL_SION_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the decl&#39;SION plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_FLOWVR_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the FlowVR plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_FTI_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the FTI plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_PYCALL_PLUGIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build Pycall plug-in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_TESTING&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the tests.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_DOCUMENTATION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the documentation website.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_INDENT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the code auto-indentation tools.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BUILD_CFG_VALIDATOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OFF&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Build the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; configuration validation script.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The following flags define whether to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use the preinstalled version of a dependency (&lt;code&gt;SYSTEM&lt;/code&gt;), it will be looked for in the system directories and those specified by the &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; list,&lt;/li&gt;
&lt;li&gt;compile the version of the dependency provided in the distribution (&lt;code&gt;EMBEDDED&lt;/code&gt;),&lt;/li&gt;
&lt;li&gt;compile another version of the dependency (the path to the source archive),&lt;/li&gt;
&lt;li&gt;use the preinstalled version of a dependency if available and fallback on the compilation of the version of the dependency provided in the distribution if no preinstalled version is found.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag&lt;/th&gt;
&lt;th&gt;Default&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_Astyle&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;http://astyle.sourceforge.net/&#34;&gt;astyle&lt;/a&gt; tool.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_Bpp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EMBEDDED&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/jbigot/zpp&#34;&gt;bpp/zpp&lt;/a&gt; preprocessor.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_Doxygen&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;http://www.doxygen.nl/&#34;&gt;doxygen&lt;/a&gt; tool.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_FlowVR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://gitlab.inria.fr/flowvr/flowvr-ex&#34;&gt;FlowVR&lt;/a&gt; framework.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_FTI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/leobago/fti&#34;&gt;FTI&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_GTest&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EMBEDDED&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt; framework.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_HDF5&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://www.hdfgroup.org/solutions/hdf5/&#34;&gt;HDF5&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_paraconf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/pdidev/paraconf&#34;&gt;paraconf&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_pybind11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://pybind11.readthedocs.io/en/stable&#34;&gt;pybind11&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_SIONlib&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the SIONlib library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_spdlog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/gabime/spdlog&#34;&gt;spdlog&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;USE_yaml&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AUTO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the &lt;a href=&#34;https://github.com/jbigot/zpp&#34;&gt;yaml&lt;/a&gt; library.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;list-of-dependencies&#34;&gt;List of dependencies&lt;/h2&gt;
&lt;p&gt;Here is a list of all dependencies required by one feature or another. All dependencies are provided in the distribution unless specified otherwise.&lt;/p&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;PDI&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://cmake.org/&#34;&gt;cmake&lt;/a&gt; version 3.5 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a C 99 and C++ 14 compiler such as &lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;gcc&lt;/a&gt; 5.4 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://github.com/pdidev/paraconf&#34;&gt;paraconf&lt;/a&gt; library version 0.4 or above,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://pyyaml.org/wiki/LibYAML&#34;&gt;libyaml&lt;/a&gt; library version 0.1 or above,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://github.com/gabime/spdlog&#34;&gt;spdlog&lt;/a&gt; library.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the Fortran API&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a Fortran 95 compiler such as &lt;a href=&#34;https://gcc.gnu.org/&#34;&gt;gcc&lt;/a&gt; 5.4 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a &lt;a href=&#34;https://www.python.org/&#34;&gt;python&lt;/a&gt; interpreter version 2.7 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a &lt;a href=&#34;https://www.gnu.org/software/bash/&#34;&gt;bash&lt;/a&gt; interpreter (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://github.com/jbigot/zpp&#34;&gt;bpp/zpp&lt;/a&gt; preprocessor version 0.3.0 or above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the Decl&#39;HDF5 plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://www.hdfgroup.org/solutions/hdf5/&#34;&gt;HDF5&lt;/a&gt; library version 1.8 or above,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a MPI implementation for the parallel version of the plugin (not provided)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the MPI plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a MPI implementation (not provided)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the Python API&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the &lt;a href=&#34;https://www.python.org/&#34;&gt;python&lt;/a&gt; development environment version 3.5 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://pybind11.readthedocs.io/en/stable&#34;&gt;pybind11&lt;/a&gt; library version 2.3 or above,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the Decl&#39;SION plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fz-juelich.de/ias/jsc/EN/Expertise/Support/Software/SIONlib/_node.html&#34;&gt;SIONlib&lt;/a&gt; version 1.7.2 or above,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the FlowVR plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitlab.inria.fr/flowvr/flowvr-ex&#34;&gt;FlowVR&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the FTI plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://github.com/leobago/fti&#34;&gt;FTI&lt;/a&gt; library version 1.3 or above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the Pycall plugin&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library with python API.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the tests&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; library,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.cmake.org/&#34;&gt;cmake&lt;/a&gt; version 3.10 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt; framework version 1.8 or above,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://astyle.sourceforge.net/&#34;&gt;astyle&lt;/a&gt; version 3.1 or above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the documentation website builder&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doxygen.nl/&#34;&gt;doxygen&lt;/a&gt; version 1.8 or above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dependencies of &lt;strong&gt;the &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; configuration validation tool&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a &lt;a href=&#34;https://www.python.org/&#34;&gt;python&lt;/a&gt; interpreter version 2.7 or above (not provided)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the &lt;a href=&#34;https://pyyaml.org/&#34;&gt;python YAML&lt;/a&gt; module (not provided)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: PDI example</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/pdi_example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/pdi_example/</guid>
      <description>
        
        
        &lt;p&gt;PDI example application can be found in repository in the &lt;code&gt;example&lt;/code&gt; directory. The source code is written in C, Fortran and Python.&lt;/p&gt;
&lt;p&gt;The example has a single source file (for each supported programming language), but specification tree to each plugin. Just by replacing the configuration file, the example program will use different libraries and different I/O operations.&lt;/p&gt;
&lt;p&gt;The example implements simple &lt;a href=&#34;https://en.wikipedia.org/wiki/Heat_equation&#34;&gt;Heat equation&lt;/a&gt; algorithm in 2 dimensional space.&lt;/p&gt;
&lt;h2 id=&#34;heat-algorithm&#34;&gt;Heat algorithm&lt;/h2&gt;
&lt;p&gt;Each element in a matrix is a point with temperature. In each iteration every cell is calculated by an weighted average of itself and neighbour cells (top, bottom, left and right):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;matrix[i][j] = 0.500 * matrix[i][j] +
               0.125 * matrix[i-1][j] +
               0.125 * matrix[i+1][j] +
               0.125 * matrix[i][j-1] +
               0.125 * matrix[i][j+1];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To not override the cells while processing we need to create temporary matrix to save results and then move result to original matrix (&lt;code&gt;cur&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; in source file). Above calculations are written in &lt;code&gt;iter&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Now we can add a MPI to our algorithm. Let&#39;s split that matrix by MPI processes. Each process will compute part of global matrix.&lt;/p&gt;
&lt;p&gt;For example: matrix 16 x 16 integers and 16 MPI processes gives submatrices of 4 x 4 integers for every process. We have to add to our global matrix one row above and below, column to the left and right to be able to compute border cells. In our example row on the top has some value (”x”) bigger than 0 (representing source of heat):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/heat_global_matrix.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;MPI processes need to exchange information about their local matrix border cells (communicate with neighbours to exchange row/column of matrix). Each MPI process will have a local matrix:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/heat_local_matrix.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;All the communications instructions are written in &lt;code&gt;exchange&lt;/code&gt; function.&lt;/p&gt;
&lt;h2 id=&#34;pdi-integration&#34;&gt;PDI integration&lt;/h2&gt;
&lt;p&gt;Now, when we know the algorithm, we can focus on analysing &lt;code&gt;decl_hdf5.yaml&lt;/code&gt; specification tree. Fisrt 3 maps defined will not be seen to PDI:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;duration: 0.75
datasize: [60, 12]
parallelism: { height: 3, width: 1 }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;duration&lt;/code&gt; is the value in seconds how long the application will run.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;datasize&lt;/code&gt; is size of our global matrix.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parallelism&lt;/code&gt; defines the number of MPI processes in each dimension.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next, we have defined &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;metadata&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdi:
  metadata:
    iter:   int
    dsize:  { size: 2, type: array, subtype: int }
    psize:  { size: 2, type: array, subtype: int }
    pcoord: { size: 2, type: array, subtype: int }
  data:
    main_field: { size: [ &#39;$dsize[0]&#39;, &#39;$dsize[1]&#39; ], type: array, subtype: double }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In source file we will extract the &lt;code&gt;pdi&lt;/code&gt; map and pass it as PDI_init argument.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iter&lt;/code&gt; will hold the current iteration number.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dsize&lt;/code&gt; will hold the size of local matrix of each MPI process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;psize&lt;/code&gt; will hold number of processes in dimensions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pcoord&lt;/code&gt; will hold coordinates for each process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main_filed&lt;/code&gt; is the local matrix for each process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s take a closer look at C source code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_init(PC_get(conf, &amp;quot;.pdi&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As mentioned before, we extract the &lt;code&gt;pdi&lt;/code&gt; subtree and pass it to PDI_init.&lt;/p&gt;
&lt;p&gt;We did not defined &lt;code&gt;mpi_comm&lt;/code&gt; data in yaml, so this line will have no effect:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_expose(&amp;quot;mpi_comm&amp;quot;, &amp;amp;main_comm, PDI_INOUT);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same goes for all PDI calls with data we didn&#39;t defined.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int dsize[2];
PC_int(PC_get(conf, &amp;quot;.datasize[0]&amp;quot;), &amp;amp;longval); dsize[0] = longval;
PC_int(PC_get(conf, &amp;quot;.datasize[1]&amp;quot;), &amp;amp;longval); dsize[1] = longval;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we are reading global matrix size from specification tree. Similar with parallelism and duration.&lt;/p&gt;
&lt;p&gt;After calculating the local matrix sizes and coordinates, we expose them:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_expose(&amp;quot;dsize&amp;quot;, dsize, PDI_OUT);
PDI_expose(&amp;quot;psize&amp;quot;, psize, PDI_OUT);
PDI_expose(&amp;quot;pcoord&amp;quot;, pcoord, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the beginning of each iteration, we call multiexpose:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PDI_multi_expose(&amp;quot;newiter&amp;quot;,
                &amp;quot;iter&amp;quot;, &amp;amp;ii, PDI_INOUT,
                &amp;quot;main_field&amp;quot;, cur, PDI_INOUT,
                NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Above instruction will share &lt;code&gt;iter&lt;/code&gt; and &lt;code&gt;main_field&lt;/code&gt;, call &lt;code&gt;newiter&lt;/code&gt; event and then reclaim &lt;code&gt;main_field&lt;/code&gt; and &lt;code&gt;iter&lt;/code&gt;. This is the place when plugins will read/write our data.&lt;/p&gt;
&lt;p&gt;We have covered the logic behind the PDI example. Now you can start the &lt;a href=&#34;compound:Hands_on&#34;&gt;Hands-on tutorial&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Plugins</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/plugins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/plugins/</guid>
      <description>
        
        
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Plugin&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:Decl_HDF5_plugin&#34;&gt;Decl&#39;HDF5 plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Read and write data from HDF5 files in a declarative way.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:FlowVR_plugin&#34;&gt;FlowVR plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Write FlowVR modules without knowing any specific FlowVR API calls.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:trace_plugin&#34;&gt;trace plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Generate a trace of what happens in PDI data store.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:user_code_plugin&#34;&gt;user-code plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Call your function on event or when data becomes available&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:set_value_plugin&#34;&gt;set_value plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Set values to data and metadata from yaml file.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:FTI_plugin&#34;&gt;FTI plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Perform checkpoints using FTI library.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;compound:pycall_plugin&#34;&gt;Pycall plugin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Call python scripts from C application&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MPI plugin&lt;/td&gt;
&lt;td&gt;Enables MPI support in PDI and plugins.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Decl&#39;SION plugin&lt;/td&gt;
&lt;td&gt;Read and write data from SIONlib files in a declarative way.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To learn how to create your own plugin see: &lt;a href=&#34;compound:how_to_create_plugin&#34;&gt;How to create a plugin&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Pycall plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/pycall_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/pycall_plugin/</guid>
      <description>
        
        
        &lt;p&gt;The Pycall plugin allows calling python scripts from yaml file, that can work either if wanted data was shared or program calls specific event.&lt;/p&gt;
&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;Simple plugin build:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  pycall:           // name of plugin
    on_event:       // run script on event
      testing:      // name of an event
        with:       // data alias
        exec:       // python code which will be executed when the event is called
    on_data:        // run script on data share
      data_name:    // python code which will be executed when data_name is shared
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;plugin-tree&#34;&gt;Plugin tree&lt;/h3&gt;
&lt;p&gt;The root of plugin configuration (named &lt;code&gt;pycall&lt;/code&gt;), is a dictionary that contains the following keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on_event&lt;/li&gt;
&lt;li&gt;on_data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;on_event&#34;&gt;on_event&lt;/h3&gt;
&lt;p&gt;This option allows to execute written python code when specific event is called.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: {a: {type: array, subtype: int, size: 3}}
plugins:
  pycall:
    on_event:
      testing:
        with: { a_python: $a }
        exec: \&amp;quot;print(&#39; * [P] I received    $a =&#39;,a_python); a_python[1]=7; print(&#39; * [P] changed it to $a =&#39;,a_python);\&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example pycall will run script on &lt;code&gt;testing&lt;/code&gt; event. In the next step in &lt;code&gt;with&lt;/code&gt; section alias name for data is generated. &lt;code&gt;a&lt;/code&gt; will be &lt;code&gt;a_python&lt;/code&gt; for execusion of the python code. Finally &lt;code&gt;exec&lt;/code&gt; contains python code that will be executed on &lt;code&gt;testing&lt;/code&gt; event.&lt;/p&gt;
&lt;p&gt;There is also an option to set a list of executions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: {a: {type: array, subtype: int, size: 3}}
plugins:
  pycall:
    on_event:
      testing:
        - exec: #some_python_script
          with: { a: $a }
        - exec: #some_other_python_script
          with: { b: $a }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;on_data&#34;&gt;on_data&lt;/h3&gt;
&lt;p&gt;This option allows to execute written python code when specific data is shared.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: {a: {type: array, subtype: int, size: 3}}
plugins:
  pycall:
    on_data:
      a: print(&#39; * [P] I received    $a =&#39;,a); a[1]=7; print(&#39; * [P] changed it to $a =&#39;,a);\&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;on_data&lt;/code&gt; is a dictionary that contains data name with the python script that will be executed on share.&lt;/p&gt;
&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;
&lt;p&gt;Full example of pycall plugin. For siplicity yaml file was included with c code in one file instead of creating separate files.&lt;/p&gt;
&lt;p&gt;Yaml file named your_file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logging: trace
    data: {a: {type: array, subtype: int, size: 3}}
    plugins:
      pycall:
        on_event:
          testing:
            with: { a_python: $a }
            exec: \&amp;quot;print(&#39; * [P] I received    $a =&#39;,a_python); a_python[1]=7; print(&#39; * [P] changed it to $a =&#39;,a_python);\&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C++ code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[3] = {1, 2, 3};

printf(&amp;quot; * [C] starting with $a = [%d %d %d]\n&amp;quot;, a[0], a[1], a[2]);

PDI_share(&amp;quot;a&amp;quot;, a, PDI_INOUT);
PDI_event(&amp;quot;testing&amp;quot;);
PDI_reclaim(&amp;quot;a&amp;quot;);

printf(&amp;quot; * [C] now I see     $a = [%d %d %d]\n&amp;quot;, a[0], a[1], a[2]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Output from the program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * [C] starting with $a = [1 2 3]
[PDI][13:51:26] *** trace: Sharing `a&#39; Ref with rights: R = true, W = true
[PDI][13:51:26] *** trace: Calling `a&#39; share. Callbacks to call: 0
[PDI][13:51:26] *** trace: Calling `testing&#39; event. Callbacks to call: 1
 * [P] I received    $a = [1 2 3]
 * [P] changed it to $a = [1 7 3]
 * [C] now I see     $a = [1 7 3]
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Set_value plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/set_value_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/set_value_plugin/</guid>
      <description>
        
        
        &lt;p&gt;The Set_value plugin allows setting values to data and metadata descriptors from the yaml file.&lt;/p&gt;
&lt;p&gt;There are 3 main features:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Share data - plugin will share new allocated data with given values&lt;/li&gt;
&lt;li&gt;Expose data - plugin will expose new allocated data with given values&lt;/li&gt;
&lt;li&gt;Set data - plugin will set given values to the already shared data&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;configuration-grammar&#34;&gt;Configuration grammar&lt;/h2&gt;
&lt;p&gt;At its root, the Set_value configuration is made of:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;on_init&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a list of &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;on_event&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;an &lt;a href=&#34;member:set_value_plugin_1on_event_map_node&#34;&gt;on_event&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;on_data&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;an &lt;a href=&#34;member:set_value_plugin_1on_data_map_node&#34;&gt;on_data&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;on_init&#34;&gt;on_init&lt;/h3&gt;
&lt;p&gt;Specifies a list of operation to do in &lt;a href=&#34;member:group__init__final_1ga3dc660be40c93c169337e3d2692b2ed0&#34;&gt;PDI_init&lt;/a&gt; function. &lt;code&gt;on_init&lt;/code&gt; is a list of &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt; s.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  set_value:
    on_init:
      - set: ... # value_list
      - share: ... # value_list
      - expose: ... # value_list
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;on_event&#34;&gt;on_event&lt;/h3&gt;
&lt;p&gt;Specifies a map of events that will trigger the values set. &lt;code&gt;on_event&lt;/code&gt; is a map with event name as a key and &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt; list as map value.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a list of &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  set_value:
    on_event:
      event_1_name:
        - set: ... # value_list
        - share: ... # value_list
        - expose: ... # value_list
      event_2_name:
        - set: ... # value_list
        - share: ... # value_list
        - expose: ... # value_list
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;on_data&#34;&gt;on_data&lt;/h3&gt;
&lt;p&gt;Specifies a map of data that on share will trigger the values set. &lt;code&gt;on_data&lt;/code&gt; is a map with data/metadata name as a key and &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt; as map value.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a list of &lt;a href=&#34;member:set_value_plugin_1value_operation&#34;&gt;value operation&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  metadata_1_name: ... # metadata_type
data:
  data_1_name: ...  # data_type
plugins:
  set_value:
    on_data:
      data_1_name:
        - set: ... # value_list
        - share: ... # value_list
        - expose: ... # value_list
      metadata_1_name:
        - set: ... # value_list
        - share: ... # value_list
        - expose: ... # value_list
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;value-operation&#34;&gt;value operation&lt;/h3&gt;
&lt;p&gt;Defines what operation to do with given &lt;a href=&#34;member:set_value_plugin_1value_list&#34;&gt;value list&lt;/a&gt;. The order of the operation is important and will be called in the same order as defined in yaml file.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;set&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:set_value_plugin_1value_list&#34;&gt;value list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;share&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:set_value_plugin_1value_list&#34;&gt;value list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;expose&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:set_value_plugin_1value_list&#34;&gt;value list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Share warning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Share is always done with read and write rights. Plugin allocates memory by &lt;code&gt;malloc&lt;/code&gt;. If you reclaim the data, you should free it with &lt;code&gt;free&lt;/code&gt; instruction. If you don&#39;t reclaim or release data, plugin will try to release all descriptors that has shared before (failure is not an error, so user can reclaim the shared data).&lt;/p&gt;
&lt;h3 id=&#34;value-list&#34;&gt;value list&lt;/h3&gt;
&lt;p&gt;Is a list of the&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;member:set_value_plugin_1scalar_value&#34;&gt;scalar value&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:set_value_plugin_1array_value&#34;&gt;array value&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:set_value_plugin_1record_value&#34;&gt;record value&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;as elements. The order of the elements is important. The descriptors will be set in the same order as given in the yaml file.&lt;/p&gt;
&lt;h3 id=&#34;scalar-value&#34;&gt;scalar value&lt;/h3&gt;
&lt;p&gt;Is a map of descriptor name as a key, and a value to set as a value:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a scalar value to set&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  scalar_name: int
set_value:
  on_init:
    - expose:
      - scalar_name: 42
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;array-value&#34;&gt;array value&lt;/h3&gt;
&lt;p&gt;Is a map of descriptor name as a key, and a list of values to set as a value:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a list of value to set&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  array_name:
    type: array
    size: 4
    subtype: int

plugins:
  set_value:
    on_init:
      - expose:
        - array_name: [2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;record-value&#34;&gt;record value&lt;/h3&gt;
&lt;p&gt;Is a map of descriptor name as a key, and a list of members to set as a value. Each member consist of an inner &lt;code&gt;value_list&lt;/code&gt;. The order of the members is unrestricted, but the plugin will set the values to the members in the same order.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a map with member name as key and a value to set as value&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  record_name:
    type: record
    buffersize: 16
    members:
      member_1:
        disp: 0
        type: array
        size: 3
        subtype: int
      member_2:
        disp: 12
        type: int

set_value:
  on_init:
    - expose:
      - record_name:
          member_2: 3 # int member
          member_1: [1, 2, 3] # array of ints member
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;full-configuration-example&#34;&gt;full configuration example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  array_size: int64

data:
  record_data:
    type: record
    buffersize: 36
    members:
      scalar_data:
        disp: 0
        type: int
      array_data:
        disp: 4
        type: array
        size: $array_size
        subtype: int

plugins:
  set_value:
    on_init:
      - expose:
        - array_size: 3
      - share:
        - record_data:
          - scalar_data: 0
          - array_data: [0, 0, 0]
    on_event:
      event_1_name:
        - set:
          - record_data:
            - scalar_data: 3
            - array_data: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;using-old-values-to-set-new&#34;&gt;Using old values to set new&lt;/h2&gt;
&lt;h3 id=&#34;increment-value&#34;&gt;Increment value&lt;/h3&gt;
&lt;p&gt;The set_value plugin allows to use the old values to set new values, you can use even the same descriptor, for example to increment a scalar.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  value_int:
    type: int
  int_array:
    size: 3
    subtype: int
    type: array
plugins:
  set_value:
    on_event:
      init:
        - share:
          - value_int: 0
          - int_array: [1, 2, 3]
      increment:
        - set:
          - value_int: &amp;quot;$value_int + 1&amp;quot;
          - int_array: [&amp;quot;$int_array[0] + 1&amp;quot;, &amp;quot;$int_array[1] + 1&amp;quot;, &amp;quot;$int_array[2] + 1&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After calling &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;increment&lt;/code&gt; event, &lt;code&gt;value_int&lt;/code&gt; will be equal 1, and &lt;code&gt;int_array&lt;/code&gt; to [2, 3, 4].&lt;/p&gt;
&lt;h3 id=&#34;getting-old-value&#34;&gt;Getting old value&lt;/h3&gt;
&lt;p&gt;The new value is set at the end of processing the whole descriptors. This means, that if you want to update the array element depending on other element, the old value will be set:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  int_array:
    size: 3
    subtype: int
    type: array
plugins:
  set_value:
    on_event:
      init:
        - expose:
          - int_array: [0, 0, 0]
      increment:
        - expose:
          - int_array: [&amp;quot;$int_array[0] + 1&amp;quot;, &amp;quot;$int_array[0] + 1&amp;quot;, &amp;quot;$int_array[1] + 1&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After calling &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;increment&lt;/code&gt; event, all values in &lt;code&gt;int_array&lt;/code&gt; will equal &lt;code&gt;1&lt;/code&gt;. This is because the &lt;code&gt;int_array[0]&lt;/code&gt; was updated after setting all the elements.&lt;/p&gt;
&lt;h3 id=&#34;getting-new-value&#34;&gt;Getting new value&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  int_scalar: int
  int_array:
    size: 3
    subtype: int
    type: array
plugins:
  set_value:
    on_event:
      init:
        - expose:
          - int_scalar: 0
          - int_array: [0, 0, 0]
      increment:
        - expose:
          - int_scalar: $int_scalar+1
          - int_array: [&amp;quot;$int_scalar&amp;quot;, &amp;quot;$int_scalar&amp;quot;, &amp;quot;$int_scalar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After calling &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;increment&lt;/code&gt; event, all values in &lt;code&gt;int_array&lt;/code&gt; will equal &lt;code&gt;1&lt;/code&gt;. This is because the &lt;code&gt;int_scalar&lt;/code&gt; is set and then the &lt;code&gt;int_array&lt;/code&gt; is updated after the &lt;code&gt;int_scalar&lt;/code&gt; has a new value.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Specification tree Reference</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/specification_tree_ref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/specification_tree_ref/</guid>
      <description>
        
        
        &lt;p&gt;The PDI specification tree is expressed in &lt;a href=&#34;https://en.wikipedia.org/wiki/YAML&#34;&gt;YAML&lt;/a&gt;. As such, it is a tree that contains 3 distinct kinds of nodes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scalars,&lt;/li&gt;
&lt;li&gt;sequences,&lt;/li&gt;
&lt;li&gt;mappings.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;scalar&lt;/strong&gt; is a leaf in the tree, represented as a string. Some form of scalars can be interpreted as a boolean, integer or floating-point valued. Simple examples of scalars include for example (see the &lt;a href=&#34;https://yaml.org/spec/1.2/spec.html#id2760844&#34;&gt;YAML specification&lt;/a&gt; for the complete syntax):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;world&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5.7&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;sequence&lt;/strong&gt; is an ordered list of sub-nodes (that can themselves be scalars, sequences or mappings). Two main syntaxes are available for sequences (see the &lt;a href=&#34;https://yaml.org/spec/1.2/spec.html#id2759963&#34;&gt;YAML specification&lt;/a&gt; for the complete syntax).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;in-line sequence: &lt;code&gt;[1, 2, 3, hello, &amp;quot;world&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;multi-line sequence:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 1
- 2
- 3
- hello
- world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A &lt;strong&gt;mapping&lt;/strong&gt; is an unordered list of key-value pairs (whose elements can themselves be scalars, sequences or mappings). Two main syntaxes are available for mapping (see the &lt;a href=&#34;https://yaml.org/spec/1.2/spec.html#id2759963&#34;&gt;YAML specification&lt;/a&gt; for the complete syntax).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;in-line mapping: &lt;code&gt;{1: one, 2: &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;: 3}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;multi-line mapping:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1: one
2: two
&amp;quot;three&amp;quot;: 3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;specification-tree-root&#34;&gt;specification tree root&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;specification tree root&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;data&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1data_map_node&#34;&gt;data_map&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;metadata&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1data_map_node&#34;&gt;data_map&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;plugins&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1plugin_map_node&#34;&gt;plugin_map&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;anything&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;metadata&lt;/code&gt; sections specify the type of the data in buffers exposed by the application; for &lt;code&gt;metadata&lt;/code&gt;, PDI keeps a copy while it only keeps references for &lt;code&gt;data&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;plugin&lt;/code&gt; section specifies the list of plugins to load and their configuration,&lt;/li&gt;
&lt;li&gt;additional sections are ignored.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  my_metadata: int
data:
  my_data:
    type: array
    subtype: double
    size: 5
plugins:
  decl_hdf5: #...
  mpi: #...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;array_type&#34;&gt;array_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;array_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;array&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;size&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1intexpr_or_seq_node&#34;&gt;intexpr_or_seq&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;subtype&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1datatype_node&#34;&gt;datatype&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;subsize&amp;quot;&lt;/code&gt; (&lt;em&gt;optional, deprecated&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1intexpr_or_seq_node&#34;&gt;intexpr_or_seq&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;start&amp;quot;&lt;/code&gt; (&lt;em&gt;optional, deprecated&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1intexpr_or_seq_node&#34;&gt;intexpr_or_seq&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;array_type_node&lt;/em&gt; represents a potentially multi-dimensional array where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the value associated to the &lt;code&gt;size&lt;/code&gt; key represents the size of the array in each dimension (C order),&lt;/li&gt;
&lt;li&gt;the value associated to the &lt;code&gt;subtype&lt;/code&gt; key represents the type of the elements in the array,&lt;/li&gt;
&lt;li&gt;the value associated to the &lt;code&gt;subsize&lt;/code&gt; key represents the number of elements to actually use in each dimension (slicing), if specified it &lt;strong&gt;must&lt;/strong&gt; have the same number of elements as &lt;code&gt;size&lt;/code&gt;, this defaults to the full array size in each dimension,&lt;/li&gt;
&lt;li&gt;the value associated to the &lt;code&gt;start&lt;/code&gt; key represents the index of the first element to actually use in each dimension (slicing), if specified it &lt;strong&gt;must&lt;/strong&gt; have the same number of elements as &lt;code&gt;size&lt;/code&gt;, this defaults to the first (0) element in each dimension.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: array
subtype: double
size: 5
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;type: array
subtype: { type: character, kind: 4 }
size: [ &#39;$size_1d&#39;, &#39;$size_2d&#39; ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;char_type&#34;&gt;char_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;char_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;char&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;char_type&lt;/em&gt; represents the C &lt;code&gt;char&lt;/code&gt; datatype; it accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: char
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;character_type&#34;&gt;character_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;character_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;character&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;kind&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;character_type_node&lt;/em&gt; represents the Fortran &lt;code&gt;character&lt;/code&gt; datatype. The value associated to the &lt;code&gt;kind&lt;/code&gt; key corresponds to the Fortran &lt;em&gt;kind&lt;/em&gt; parameter (&lt;code&gt;character(kind=...)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: character
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;type: character
kind: 4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;datatype&#34;&gt;datatype&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;datatype&lt;/em&gt; can be &lt;strong&gt;any of&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1array_type_node&#34;&gt;array_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1char_type_node&#34;&gt;char_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1character_type_node&#34;&gt;character_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1double_type_node&#34;&gt;double_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1float_type_node&#34;&gt;float_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1int_type_node&#34;&gt;int_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1int16_type_node&#34;&gt;int16_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1int32_type_node&#34;&gt;int32_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1int64_type_node&#34;&gt;int64_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1int8_type_node&#34;&gt;int8_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1integer_type_node&#34;&gt;integer_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1logical_type_node&#34;&gt;logical_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1real_type_node&#34;&gt;real_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1record_type_node&#34;&gt;record_type&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1simple_datatype_node&#34;&gt;simple_datatype&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amongst these, &lt;a href=&#34;member:Specification_tree_ref_1simple_datatype_node&#34;&gt;simple_datatype&lt;/a&gt; is the only scalar. All others are dictionaries with a &lt;code&gt;type&lt;/code&gt; key used for disambiguation between them. Plugins can add new options that follow the same pattern.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;datatype&lt;/em&gt; represents the memory layout and interpretation for data exposed by the user in the &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;data store&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;data_map&#34;&gt;data_map&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;data_map&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1datatype_node&#34;&gt;datatype&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a buffer exposed to PDI associated to its type.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_data_1: int
my_data_2: {type: array, subtype: double, size: 5}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;double_type&#34;&gt;double_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;double_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;double&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;double_type&lt;/em&gt; represents the C &lt;code&gt;double&lt;/code&gt; type. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: double
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-expression&#34;&gt;$-expression&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;$-expression&lt;/em&gt; is a &lt;strong&gt;scalar&lt;/strong&gt; whose content matches the following grammar:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* parsing as a REFERENCE is preferred over OPERATION
   parsing as an OPERATION is preferred over STRING_LITERAL
*/
EXPRESSION     := REFERENCE | OPERATION | STRING_LITERAL

STRING_LITERAL := ( CHAR | &#39;\&#39; &#39;\&#39; | &#39;\&#39; &#39;$&#39;
                  | REFERENCE
                  | &#39;$&#39; &#39;(&#39; OPERATION &#39;)&#39;
                  )*

/* The operator descending precedence order is:
   1. *, /, %: multiplication, division and modulo,
   2. +, -: addition and subtraction,
   3. &amp;lt;, &amp;gt;: less than and greater than,
   4. =: equality,
   5. &amp;amp;: logical AND,
   6. |: logical OR.
*/
OPERATION      := TERM ( OPERATOR TERM )*

TERM           := ( INT_LITERAL | REFERENCE | &#39;(&#39; OPERATION &#39;)&#39; )

REFERENCE      := &#39;$&#39; ( IREFERENCE | &#39;{&#39; IREFERENCE &#39;}&#39; )

IREFERENCE     := ID ( &#39;[&#39; OPERATION &#39;]&#39; )*



INT_LITERAL ~= (0x)? [0-9]+ ( \.  )
ID          ~= [a-zA-Z_][a-zA-Z0-9_]*
CHAR        ~= [^$\\]
OPERATOR    ~= [|&amp;amp;=&amp;lt;&amp;gt;+\-\*/%]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The rules for evaluating an expression are close to those of BASH for example.&lt;/p&gt;
&lt;p&gt;In addition to raw text, a &lt;code&gt;STRING_LITERAL&lt;/code&gt; can contain references to the string value of some data in the store as well as the result of an operation by enclosing it inside a dollar-parenthesis &lt;code&gt;$()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;OPERATION&lt;/code&gt; can include logical and arithmetic operators grouped by parenthesis. The basic terms manipulated in an operation can be integer literals or references to the integer value of some data in the store.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;REFERENCE&lt;/code&gt; is introduced by a dollar &lt;code&gt;$&lt;/code&gt; sign and optionally enclosed in curly braces &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;. Its value is that of the data or metadata with the associated name. It is always a good idea to have referenced values in the metadata section as it prevents dangling references. A direct reference is possible as well as sub-references to array elements using the square brackets &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; operator.&lt;/p&gt;
&lt;p&gt;The value-type of an &lt;code&gt;EXPRESSION&lt;/code&gt; is as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if it&#39;s a &lt;code&gt;REFERENCE&lt;/code&gt;, it has the type of the referenced data in the store,&lt;/li&gt;
&lt;li&gt;if it&#39;s a &lt;code&gt;OPERATION&lt;/code&gt;, it is integer-valued,&lt;/li&gt;
&lt;li&gt;if it&#39;s a &lt;code&gt;STRING_LITERAL&lt;/code&gt;, it is string-valued.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, an integer can be interpreted as a string or as a boolean value where zero is interpreted as false and any other value as true.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;$my_data&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&#39;($my_data + 3) % 6&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&#39;my name is ${my_name}&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;float_type&#34;&gt;float_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;float_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;float&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1float_type_node&#34;&gt;float_type&lt;/a&gt; represents the C &lt;code&gt;float&lt;/code&gt; type. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: float
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;int_type&#34;&gt;int_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;int_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;int&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1int_type_node&#34;&gt;int_type&lt;/a&gt; represents the C &lt;code&gt;int&lt;/code&gt; type. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: int
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;int16_type&#34;&gt;int16_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;int16_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;int16&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1int16_type_node&#34;&gt;int16_type&lt;/a&gt; represents the C &lt;code&gt;int16_t&lt;/code&gt; type from the &lt;code&gt;&amp;lt;stdtypes.h&amp;gt;&lt;/code&gt; header. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: int16
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;int32_type&#34;&gt;int32_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;int32_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;int32&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1int32_type_node&#34;&gt;int32_type&lt;/a&gt; represents the C &lt;code&gt;int32_t&lt;/code&gt; type from the &lt;code&gt;&amp;lt;stdtypes.h&amp;gt;&lt;/code&gt; header. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: int32
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;int64_type&#34;&gt;int64_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;int64_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;int64&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;int64_type&lt;/em&gt; represents the C &lt;code&gt;int64_t&lt;/code&gt; type from the &lt;code&gt;&amp;lt;stdtypes.h&amp;gt;&lt;/code&gt; header. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: int64
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;int8_type&#34;&gt;int8_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;int8_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;int8&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1int8_type_node&#34;&gt;int8_type&lt;/a&gt; represents the C &lt;code&gt;int8_t&lt;/code&gt; type from the &lt;code&gt;&amp;lt;stdtypes.h&amp;gt;&lt;/code&gt; header. It accepts no parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: int8
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;integer_type&#34;&gt;integer_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;integer_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;integer&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;kind&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;integer_type&lt;/em&gt; represents the Fortran &lt;code&gt;integer&lt;/code&gt; datatype. The value associated to the &lt;code&gt;kind&lt;/code&gt; key corresponds to the Fortran &lt;em&gt;kind&lt;/em&gt; parameter (&lt;code&gt;integer(kind=...)&lt;/code&gt;). If missing, the default kind of the Fortran implementation is used.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: integer
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;type: integer
kind: 2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;intexpr_seq&#34;&gt;intexpr_seq&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;intexpr_seq&lt;/em&gt; is a &lt;strong&gt;sequence&lt;/strong&gt; where each element of the sequence is a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ 1, &#39;2&#39;, &#39;$size&#39;, &#39;$other_size + 2&#39; ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;intexpr_or_seq&#34;&gt;intexpr_or_seq&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;intexpr_or_seq&lt;/em&gt; can be &lt;strong&gt;any of&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;member:Specification_tree_ref_1intexpr_seq_node&#34;&gt;intexpr_seq&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In that context, a simple &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;$-expression&lt;/a&gt; is interpreted as a shortcut for a sequence containing a single &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;$-expression&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For example, the following value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;$x + 2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is interpreted as if it was:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ &amp;quot;$x + 2&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;logical_type&#34;&gt;logical_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;logical_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;logical&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;kind&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;logical_type&lt;/em&gt; represents the Fortran &lt;code&gt;logical&lt;/code&gt; datatype. The value associated to the &lt;code&gt;kind&lt;/code&gt; key corresponds to the Fortran &lt;em&gt;kind&lt;/em&gt; parameter (&lt;code&gt;logical(kind=...)&lt;/code&gt;). If missing, the default kind of the Fortran implementation is used.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: logical
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;type: logical
kind: 1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;member_desc&#34;&gt;member_desc&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;member_desc&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;disp&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;code&gt;scalar&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt; or &lt;code&gt;record&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;anything&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;the value associated to the &lt;code&gt;disp&lt;/code&gt; key identifies the displacement in bytes from the base address of the record and the address of this specific member,&lt;/li&gt;
&lt;li&gt;the value associated to the &lt;code&gt;type&lt;/code&gt; key identifies the &lt;a href=&#34;member:Specification_tree_ref_1datatype_node&#34;&gt;type&lt;/a&gt; of this record, all other keys required for this &lt;a href=&#34;member:Specification_tree_ref_1datatype_node&#34;&gt;datatype&lt;/a&gt; must be present.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_char:
      disp: 0
      type: int64
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;my_array:
  disp: 8
  type: array
  subtype: int64
  size: [10, 10]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See &lt;a href=&#34;member:Specification_tree_ref_1record_type_node&#34;&gt;record_type&lt;/a&gt; for more examples.&lt;/p&gt;
&lt;h2 id=&#34;members_map&#34;&gt;members_map&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;members_map&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1member_desc_node&#34;&gt;member_desc&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a member of the record and the value associated to it describes the member itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See &lt;a href=&#34;member:Specification_tree_ref_1record_type_node&#34;&gt;record_type&lt;/a&gt; for an example.&lt;/p&gt;
&lt;h2 id=&#34;plugin_map&#34;&gt;plugin_map&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;plugin_map&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;anything&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a plugin to load associated to its configuration; the content of the configuration depends on the plugin.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Have a look at the &lt;a href=&#34;compound:Plugins&#34;&gt;plugins&lt;/a&gt; documentation to see the specification tree they accept.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&#34;member:Specification_tree_ref_1root_node&#34;&gt;specification tree root&lt;/a&gt; for an example.&lt;/p&gt;
&lt;h2 id=&#34;real_type&#34;&gt;real_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;real_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;real&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;kind&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;em&gt;real_type&lt;/em&gt; represents the Fortran &lt;code&gt;real&lt;/code&gt; datatype. The value associated to the &lt;code&gt;kind&lt;/code&gt; key corresponds to the Fortran &lt;em&gt;kind&lt;/em&gt; parameter (&lt;code&gt;real(kind=...)&lt;/code&gt;). If missing, the default kind of the Fortran implementation is used.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: real
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;type: real
kind: 8
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;record_type&#34;&gt;record_type&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;record_type&lt;/em&gt; is a &lt;strong&gt;mapping&lt;/strong&gt; that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;type&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;record&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;buffersize&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1expression_node&#34;&gt;integer-valued $-expression&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;members&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:Specification_tree_ref_1members_map_node&#34;&gt;members_map&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A &lt;a href=&#34;member:Specification_tree_ref_1record_type_node&#34;&gt;record_type&lt;/a&gt; represents a &amp;quot;record&amp;quot;, &lt;em&gt;aka&lt;/em&gt; C &amp;quot;struct&amp;quot;, C++ &amp;quot;class&amp;quot;, Fortran &amp;quot;derived type&amp;quot; where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the value associated to the &lt;code&gt;buffersize&lt;/code&gt; key represents the overall size of the record, including potential padding,&lt;/li&gt;
&lt;li&gt;the value associated to the &lt;code&gt;members&lt;/code&gt; key lists all members of the record.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: record
buffersize: 8
members:
  first_int:
    disp: 0
    type: int32
  seconf_int:
    disp: 4
    type: int32
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;simple_datatype&#34;&gt;simple_datatype&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;simple_datatype&lt;/em&gt; is a &lt;strong&gt;scalar&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It is interpreted as a shortcut for a mapping with a single key &lt;code&gt;type&lt;/code&gt; whose value is the provided scalar and therefore another &lt;a href=&#34;member:Specification_tree_ref_1datatype_node&#34;&gt;datatype&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For example, the following value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;my_type&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is interpreted as if it was:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ type: &amp;quot;my_type&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: The Decl&#39;HDF5 plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/decl_hdf5_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/decl_hdf5_plugin/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; This documentation is a work in progress and does not reflect the full Decl&#39;HDF5 potential.&lt;/p&gt;
&lt;p&gt;The Decl&#39;HDF5 plugin enables one to read and write data from HDF5 files in a declarative way. Decl&#39;HDF5 does not support the full HDF5 feature set but offers a simple declarative interface to access a large subset of it.&lt;/p&gt;
&lt;h2 id=&#34;configuration-grammar&#34;&gt;Configuration grammar&lt;/h2&gt;
&lt;p&gt;At its root, the Decl&#39;HDF5 configuration is made of either a single &lt;code&gt;FILE_DESC&lt;/code&gt; or a list of &lt;code&gt;FILE_DESC&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&#34;ttfile_desctt&#34;&gt;&amp;lt;tt&amp;gt;FILE_DESC&amp;lt;/tt&amp;gt;&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;FILE_DESC&lt;/code&gt; specifies a list of actions to execute in one file. It is specified by a key/value map that contains at least the &lt;code&gt;file&lt;/code&gt; key. Other keys are optional. The possible values for the keys are as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt;: a string that can contain $-expressions and specified the name of the file this &lt;code&gt;FILE_DESC&lt;/code&gt; refers to.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write&lt;/code&gt;: a &lt;code&gt;DATA_SECTION&lt;/code&gt; that defaults to an empty one. This &lt;code&gt;DATA_SECTION&lt;/code&gt; describes writes to execute.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write&lt;/code&gt;: a &lt;code&gt;DATA_SECTION&lt;/code&gt; that defaults to an empty one. This &lt;code&gt;DATA_SECTION&lt;/code&gt; describes reads to execute.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_event&lt;/code&gt;: a string identifying an event when the whole file is accessed. If not specified, each data is written when it is exposed and the file is opened and closed every time.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;when&lt;/code&gt;: a $-expression specifying a default condition to test before executing the reads and writes of this &lt;code&gt;FILE_DESC&lt;/code&gt;. This can be replaced by a more specific condition inside the &lt;code&gt;DATA_SECTION&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;communicator&lt;/code&gt;: a $-expression referencing a MPI communicator to use for HDF5 parallel synchronized reads and writes. It defaults to MPI_COMM_SELF which stands for sequential writes. In case of data-triggered (vs. event-triggered) reads and writes, this can be replaced inside the &lt;code&gt;DATA_SECTION&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;datasets&lt;/code&gt;: a key-value map associating a &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; type to string keys. Each string is the name of a dataset to create in the file on first access, with the type described in the value.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ttdata_sectiontt&#34;&gt;&amp;lt;tt&amp;gt;DATA_SECTION&amp;lt;/tt&amp;gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;DATA_SECTION&lt;/code&gt; describes a set of I/O (read or write) to execute. A data section can take multiple forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a list of strings, each being the name of a &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; data to write&lt;/li&gt;
&lt;li&gt;a key-value map where each key is the name of a &lt;a href=&#34;compound:namespacePDI&#34;&gt;PDI&lt;/a&gt; data to write and the value is either a single &lt;code&gt;DATA_IO_DESC&lt;/code&gt; or a list of &lt;code&gt;DATA_IO_DESC&lt;/code&gt;s describing the I/O (read or write) to execute.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first case behaves as if each data had its &lt;code&gt;DATA_IO_DESC&lt;/code&gt; specified with all default values.&lt;/p&gt;
&lt;h3 id=&#34;ttdata_io_desctt&#34;&gt;&amp;lt;tt&amp;gt;DATA_IO_DESC&amp;lt;/tt&amp;gt;&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;DATA_IO_DESC&lt;/code&gt; is a key-velue map describing one I/O (read or write) to execute. All keys are optional and have default values. The possible values for the keys are as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dataset&lt;/code&gt;: a $-expression identifying the name of the dataset to access in the file. If not specified this defaults to the name of the data. On writing, if the dataset does not exist in the file and is not specified in the &lt;code&gt;FILE_DESC&lt;/code&gt; then a dataset with the same size as the memory selection is automatically created.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;when&lt;/code&gt;: a $-expression specifying a condition to test before executing the I/O operation (read or write). This defaults to the value specified in the &lt;code&gt;FILE_DESC&lt;/code&gt; if present or to unconditional I/O otherwise.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;communicator&lt;/code&gt;: a $-expression referencing a MPI communicator to use for HDF5 parallel synchronized I/O operation (read or write). Specifying communicator at this level is incompatible with event-triggered (vs. data-triggered) This defaults to the value specified in the &lt;code&gt;FILE_DESC&lt;/code&gt; if present or to sequential (MPI_COMM_SELF) I/O otherwise.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory_selection&lt;/code&gt;: a &lt;code&gt;SELECTION_DESC&lt;/code&gt; specifying the selection of data in memory to read or write. It defaults to selecting the whole data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataset_selection&lt;/code&gt;: a &lt;code&gt;SELECTION_DESC&lt;/code&gt; specifying the selection of data in the file data to write or read. This is only valid if the&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ttselection_desctt&#34;&gt;&amp;lt;tt&amp;gt;SELECTION_DESC&amp;lt;/tt&amp;gt;&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;SELECTION_DESC&lt;/code&gt; is a key-value map that describes the selection of a subset of data from a larger set. All keys are optional and have default values. The possible values for the keys are as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt; is either a single $-expression or a list of $-expressions. It describes the size of the selection in each dimension. If not specified, it defaults to the dimension of the whole data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt; is either a single $-expression or a list of $-expressions. It describes the number of point to skip in each dimension. If not specified it defaults to 0 in all dimensions. In practice, it can only be specified if &lt;code&gt;size&lt;/code&gt; is also.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;full-configuration-example&#34;&gt;full configuration example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;metadata: # small values for which PDI keeps a copy
  width:   int                    # per proc. width including ghost
  height:  int                    # per proc. height including ghost
  pwidth:  int                    # nb proc. in the x dim
  pheight: int                    # nb proc. in the y dim
  iter:    int                    # curent iteration id
  coord:   { type: array, subtype: int, size: 2 } # coordinate of the process as [x, y]
data:     # values that are not copied by PDI
  main_field:
    type: array
    subtype: double
    size: [$width, $height]
plugins:
  mpi: # loading MPI_Comm predefines (e.g. $MPI_COMM_WORLD)
  decl_hdf5: # a list of file to write to (can be a single element)
    file: data${coord[0]}x${coord[1]}.h5 # the file in which to write the data (required)
    on_event: newiter                    # the event that triggers these actions (default: trigger on data expose)
    when: &amp;quot;$iter&amp;gt;0 &amp;amp; $iter&amp;lt;11&amp;quot;           # a condition when to actually trigger the actions (default: always true)
    communicator: $MPI_COMM_SELF         # the MPI communicator used for HDF5 parallel synchronized write (default: $MPI_COMM_SELF, sequential write)
    datasets:                            # a list of datasets inside the file created on first access
      data/array: # a dataset name, datasets referenced but not defined are created just big enough to fit the data
        type: array
        subtype: double                # type of the data in the dataset
        size: [10, $width-2, $width-2] # size of the dataset
    write: # a list or map of data to write (default: empty)
      main_field: # name of the data, it contains either a list or a single write to execute
        - dataset: data/array      # a dataset name (default: the data name)
          when: &amp;quot;$iter&amp;gt;0&amp;amp;$iter&amp;lt;11&amp;quot; # an additional condition when to actually trigger the actions (default: always true)
          communicator: $MPI_COMM_SELF   # the MPI communicator used for HDF5 parallel synchronized write (default: that of the file)
          memory_selection:
            size:  [$width-2, $height-2] # number of elements to transfer in each dimension (default: size of the full data)
            start: [1, 1]                # coordinate of the start point in memory relative to the shared data (default: 0 in each dimensions)
          dataset_selection:
            size:  [1, $width-2, $width-2] # number of elements to transfer in each dimension, must amount to the same number as the memory selection (default: size of memory slab)
            start: [$iter, 0, 0]           # coordinate of the start point in the file relative to the dataset (default: 0 in each dimensions)
    read: # a list or map of data to read, similar to write (default: empty)
      - another_value
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: The FlowVR plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/flowvr_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/flowvr_plugin/</guid>
      <description>
        
        
        &lt;p&gt;The &lt;a href=&#34;http://flowvr.sourceforge.net&#34;&gt;FlowVR&lt;/a&gt; plugin lets you write FlowVR modules without knowing any specific FlowVR API calls. Properly created PDI configuration file allows you to care only about proper input/output calls, but this plugin does not support the full FlowVR feature set.&lt;/p&gt;
&lt;h2 id=&#34;configuration-elements&#34;&gt;Configuration elements&lt;/h2&gt;
&lt;h3 id=&#34;flowvr-plugin-tree&#34;&gt;FlowVR plugin tree&lt;/h3&gt;
&lt;p&gt;The root of FlowVR plugin configuration (named &lt;code&gt;flowvr&lt;/code&gt;), is a dictionary that contains the following keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1component_node&#34;&gt;component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1wait_on_data_node&#34;&gt;wait_on_data&lt;/a&gt; (&lt;em&gt;recommended&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1wait_on_node&#34;&gt;wait_on&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1status_node&#34;&gt;status&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1abort_on_node&#34;&gt;abort_on&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1init_on_node&#34;&gt;init_on&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1input_ports&#34;&gt;input_ports&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;member:FlowVR_plugin_1output_ports&#34;&gt;output_ports&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;component&#34;&gt;component&lt;/h4&gt;
&lt;p&gt;For now only available component is &lt;code&gt;module&lt;/code&gt;, but this can be expanded to &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;synchronizer&lt;/code&gt; in the future. Configuration example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  flowvr:
    component: module
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;wait_on_data&#34;&gt;wait_on_data&lt;/h4&gt;
&lt;p&gt;The plugin will call &lt;code&gt;wait&lt;/code&gt; funciton every time given descriptors will be shared with &lt;code&gt;PDI_IN&lt;/code&gt; access direction. This descriptor must be an integer type and the status returned from this call will be written as a response. Configuration example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int

plugins:
  flowvr:
    component: module
    wait_on_data: wait_desc
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;wait_on&#34;&gt;wait_on&lt;/h4&gt;
&lt;p&gt;Defines on which events the plugin calls the &lt;code&gt;wait&lt;/code&gt; function. The value can be either single event name or the array of events names (both examples presented below). This method of calling &lt;code&gt;wait&lt;/code&gt; should be avoided if possible, because it&#39;s not returning the wait status. Configuration examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
  flowvr:
    component: module
    wait_on: &amp;quot;wait_event&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;plugins:
  flowvr:
    component: module
    wait_on: [&amp;quot;wait_event_1&amp;quot;, &amp;quot;wait_event_2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;status&#34;&gt;status&lt;/h4&gt;
&lt;p&gt;PDI will copy the status of the module to the given descriptor. The same as the &lt;code&gt;wait_on&lt;/code&gt; it can be a single name or an array of names. Configuration example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int
  status_desc: int

plugins:
  flowvr:
    component: module
    wait_on_data: wait_desc
    status: status_desc
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;abort_on&#34;&gt;abort_on&lt;/h4&gt;
&lt;p&gt;Defines on which events the plugin calls the &lt;code&gt;abort&lt;/code&gt; function which will stop the flowvr application. The value can be either single event name or the array of events names. Configuration examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int

plugins:
  flowvr:
   component: module
    wait_on_data: wait_desc
    abort_on: &amp;quot;abort_event&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;init_on&#34;&gt;init_on&lt;/h4&gt;
&lt;p&gt;Defining this subtree tells PDI that the plugin should be initialized not on &lt;code&gt;PDI_init&lt;/code&gt;, but on given event.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int

plugins:
  flowvr:
   component: module
    wait_on_data: wait_desc
    init_on: &amp;quot;init_event&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;parallel&#34;&gt;parallel&lt;/h4&gt;
&lt;p&gt;This node can be for reading rank and size of the world, but also can be for setting this values. &lt;code&gt;get_rank&lt;/code&gt; will copy process&#39;s rank to given descriptor on share, &lt;code&gt;get_size&lt;/code&gt; will save the world size the same way. Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int
  rank_desc: int
  size_desc: int

plugins:
  flowvr:
    component: module
    wait_on_data: wait_desc
    parallel:
      get_rank: rank_desc
      get_size: size_desc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Values (use &lt;code&gt;$&lt;/code&gt; expression) from descriptors defined in &lt;code&gt;set_rank&lt;/code&gt; and &lt;code&gt;set_size&lt;/code&gt; will be passed to flowvr and set the environment. Setting this parameters must occur before plugin initialization. For this you need to use &lt;code&gt;init_on&lt;/code&gt; event and call this event after setting rank and size.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_desc: int
  rank_desc: int
  size_desc: int

plugins:
  flowvr:
    component: module
    wait_on_data: wait_desc
    parallel:
      set_rank: $rank_desc
      set_size: $size_desc
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;several-modules&#34;&gt;Several modules&lt;/h4&gt;
&lt;p&gt;Single program can run several modules at once. To make it work just create array of modules in &lt;code&gt;flowvr&lt;/code&gt; tree. Configuration example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  wait_1: int
  wait_2: int

flowvr:
  - component: module
    wait_on_data: wait_1
    ...
  - component: module
    wait_on_data: wait_2
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ports&#34;&gt;Ports&lt;/h3&gt;
&lt;h4 id=&#34;input_ports&#34;&gt;input_ports&lt;/h4&gt;
&lt;p&gt;Input ports are defined in &lt;code&gt;input_ports&lt;/code&gt; tree. Each port is defined by name and &lt;a href=&#34;member:FlowVR_plugin_1message&#34;&gt;Message&lt;/a&gt; it will receive. You can add &lt;code&gt;event_port: true&lt;/code&gt; to define this as event port (non-blocking).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowvr:
  ...
  input_ports:
    port_name_1:
      ...
    port_name_2:
      event_port: true
      ...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;output_ports&#34;&gt;output_ports&lt;/h4&gt;
&lt;p&gt;Output ports are defined in &lt;code&gt;output_ports&lt;/code&gt; tree. Each port is defined by name and &lt;a href=&#34;member:FlowVR_plugin_1message&#34;&gt;Message&lt;/a&gt; it will send.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowvr:
  ...
  output_ports:
    port_name_1: ...
    port_name_2: ...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;message&#34;&gt;Message&lt;/h3&gt;
&lt;p&gt;Flowvr message consists of payload and stamps. The &lt;code&gt;payload&lt;/code&gt; is defined by user by a specific key in port definition:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;message type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;data&amp;quot;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;member:FlowVR_plugin_1data_payload&#34;&gt;Data payload&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;chunks&amp;quot;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;member:FlowVR_plugin_1chunks_payload&#34;&gt;Chunk payload&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;event_button&amp;quot;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;member:FlowVR_plugin_1button_payload&#34;&gt;Event button payload&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;event_mouse&amp;quot;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;member:FlowVR_plugin_1mouse_payload&#34;&gt;Event mouse payload&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If none of the message type will be given, plugin will create a STAMP port (message has no payload). &lt;code&gt;stamps&lt;/code&gt; are described in &lt;a href=&#34;member:FlowVR_plugin_1stamp&#34;&gt;Stamp&lt;/a&gt; section.&lt;/p&gt;
&lt;h4 id=&#34;data-payload&#34;&gt;Data payload&lt;/h4&gt;
&lt;p&gt;Requires &lt;code&gt;data&lt;/code&gt; key in a port tree. This configuration means that module will send simple buffer. The plugin doesn&#39;t know the type of sending data. The value of &lt;code&gt;data&lt;/code&gt; key is the name of the descriptor where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for input port - FlowVR plugin will write to received data&lt;/li&gt;
&lt;li&gt;for output port - FlowVR plugin will read from to send data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example of &lt;code&gt;data&lt;/code&gt; in output port:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  data_desc: {type: array, subtype: int, size: 32}

flowvr:
  ...
  output_ports:
    port_name:
      data: data_desc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The user can not always predict how many data will receive. In this case &lt;code&gt;size&lt;/code&gt; node type must be a name of metadata where to write the size of received payload. This metadata will hold the size of received array. The &lt;code&gt;size&lt;/code&gt; property of descriptor should be divided by size of single element. Example of receiving unknown payload size:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  received_size : int
data:
  data_descriptor_name: {type: array, subtype: int, size: $received_size/4}

plugins:
  flowvr:
    ...
    input_ports:
      port_name:
        data: data_descriptor_name
        size: received_size
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In case that you want to send only a part of the data from descriptor you can specify it in &lt;code&gt;copy_data_selection&lt;/code&gt; tree defining datatype the same way as for descriptors. Simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  data_descriptor_name:  {type: array, subtype: int, size: [32, 32]}

flowvr:
  ...
  output_ports:
    port_name:
      data: data_descriptor_name
      copy_data_selection:
        type: array
        subtype: int
        size: [32, 32]
        subsize: [30, 30]
        start: [1, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;chunk-payload&#34;&gt;Chunk payload&lt;/h3&gt;
&lt;p&gt;Requires &lt;code&gt;chunks&lt;/code&gt; key in a port tree. This configuration means that module will send several buffers in one payload. Value of the &lt;code&gt;chunks&lt;/code&gt; key is the list of &lt;a href=&#34;member:FlowVR_plugin_1data_payload&#34;&gt;Data payload&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;WARNING&lt;/p&gt;
&lt;p&gt;After each wait, the first access to the any descriptor (that belongs to the chunks) will allocate the memory for the all descriptors. This means that all sizes (if stored as metadata) should be set before first access to any of the descriptors.&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;data:
  chunk_1_name: int
  chunk_2_name: {type: array, subtype: char, size: 255}
  chunk_3_name: float

flowvr:
  ...
  output_ports:
    port_name:
      chunks:
        - data: chunk_1_name
        - data: chunk_2_name
        - data: chunk_3_name
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;event-button-payload&#34;&gt;Event button payload&lt;/h3&gt;
&lt;p&gt;Requires &lt;code&gt;event_button&lt;/code&gt; key in a port tree. The payload holds the values of the keyboard keys pressed during iteration.&lt;/p&gt;
&lt;p&gt;The full list of predefined keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key in configuration&lt;/th&gt;
&lt;th&gt;key on keyboard&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F1&lt;/td&gt;
&lt;td&gt;F1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F2&lt;/td&gt;
&lt;td&gt;F2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F3&lt;/td&gt;
&lt;td&gt;F3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F4&lt;/td&gt;
&lt;td&gt;F4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F5&lt;/td&gt;
&lt;td&gt;F5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F6&lt;/td&gt;
&lt;td&gt;F6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F7&lt;/td&gt;
&lt;td&gt;F7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F8&lt;/td&gt;
&lt;td&gt;F8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F9&lt;/td&gt;
&lt;td&gt;F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F10&lt;/td&gt;
&lt;td&gt;F10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F11&lt;/td&gt;
&lt;td&gt;F11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_F12&lt;/td&gt;
&lt;td&gt;F12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_UP&lt;/td&gt;
&lt;td&gt;Up Arrow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_DOWN&lt;/td&gt;
&lt;td&gt;Down Arrow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_LEFT&lt;/td&gt;
&lt;td&gt;Left Arrow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_RIGHT&lt;/td&gt;
&lt;td&gt;Right Arrow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_PAGE_UP&lt;/td&gt;
&lt;td&gt;Page Up&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_PAGE_DOWN&lt;/td&gt;
&lt;td&gt;Page Down&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_HOME&lt;/td&gt;
&lt;td&gt;Home&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_END&lt;/td&gt;
&lt;td&gt;End&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KEY_INSERT&lt;/td&gt;
&lt;td&gt;Insert&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Value for each key in configuration is a descriptor of integer type. You need to make sure that you are setting this descriptors with correct values on each iteration. Example of configuration with arrow buttons:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  up: int
  down: int
  left: int
  right: int

flowvr:
  ...
  output_ports:
    port_name:
      event_button:
        KEY_UP: up
        KEY_DOWN: down
        KEY_LEFT: left
        KEY_RIGHT: right
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;event-mouse-payload&#34;&gt;Event mouse payload&lt;/h3&gt;
&lt;p&gt;Requires &lt;code&gt;event_mouse&lt;/code&gt; key in a port tree. The payload holds the values of the mouse keys pressed and cursor position during iteration. The button state is saved in descriptors of integer type and a cursor position in an array of 2 floats.&lt;/p&gt;
&lt;p&gt;Available keys in &lt;code&gt;event_mouse&lt;/code&gt; tree:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;POS_XY&lt;/td&gt;
&lt;td&gt;cursor position&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LEFT_BUTTON&lt;/td&gt;
&lt;td&gt;left mouse button&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIDDLE_BUTTON&lt;/td&gt;
&lt;td&gt;middle mouse button&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RIGHT_BUTTON&lt;/td&gt;
&lt;td&gt;right mouse button&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Example of configuration with all keys defined:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  pos_xy: {type: array, subtype: float, size: 2}
  left_button: int
  right_button: int
  middle_button: int

flowvr:
  ...
  output_ports:
    port_name:
      event_mouse:
        POS_XY: pos_xy
        LEFT_BUTTON: left_button
        RIGHT_BUTTON: right_button
        MIDDLE_BUTTON: middle_button
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;stamp&#34;&gt;Stamp&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;stamps&lt;/code&gt; key must be defined in a port tree. The value of &lt;code&gt;stamps&lt;/code&gt; is simply a map with the stamp name and descriptor name. The given descriptor must have a valid PDI type, limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array of ints&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array of floats&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array of chars&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example of message with &lt;a href=&#34;member:FlowVR_plugin_1data_payload&#34;&gt;Data payload&lt;/a&gt; and 2 stamps:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
  data_desc: {type: array, subtype: int, size: 256}
  stamp_1_desc: int
  stamp_2_desc: {type: array, subtype: float, size: 2}

flowvr:
  ...
  output_ports:
    port_name:
      data: data_desc
      stamps:
        stamp_1_name: stamp_1_desc
        stamp_2_name: stamp_2_desc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For output port stamp can be also define as an expression, but stamp will need type definition in this case. Example of expression stamp:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  value_desc: int

flowvr:
  ...
  output_ports:
    port_name:
      stamps:
        stamp_name:
          type: int
          expression: ($value_desc/2) * 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For now only int and string stamps are supported as expression.&lt;/p&gt;
&lt;h2 id=&#34;reading-and-writing-data-examples&#34;&gt;Reading and writing data examples&lt;/h2&gt;
&lt;p&gt;FlowVR plugin uses 2 ways to handle data reading and writing:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Access the shared memory - the fastest way, user operates on flowvr shared memory.&lt;/li&gt;
&lt;li&gt;Copy the data from shared memory to descriptor - needs the data copy (convenient for small messages or sparse data types).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;read-data-from-flowvr-message-by-access-the-shared-memory&#34;&gt;Read data from FlowVR message by access the shared memory&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  text_shr: {type: array, subtype: char, size: 4}

...
    input_ports:
      text:
        data: text_shr
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;char* text_shr;
PDI_access(&amp;quot;text_shr&amp;quot;, (void**)&amp;amp;text_shr, PDI_IN);

// do something with text_shr or copy data to local buffer

PDI_release(&amp;quot;text_shr&amp;quot;); // really important to release descriptors
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;write-data-from-flowvr-message-by-access-the-shared-memory&#34;&gt;Write data from FlowVR message by access the shared memory&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  text_shr: {type: array, subtype: char, size: 4}

...
    output_ports:
      text:
        data: text_shr
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;char* text_shr;
PDI_access(&amp;quot;text_shr&amp;quot;, (void**)&amp;amp;text_shr, PDI_OUT);

// do something with text_shr or copy data from local buffer

PDI_release(&amp;quot;text_shr&amp;quot;); // really important to release descriptors
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;read-data-from-flowvr-message-by-copy-from-the-shared-memory&#34;&gt;Read data from FlowVR message by copy from the shared memory&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  text: {type: array, subtype: char, size: 4}

...
    input_ports:
      text:
        data: text
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;char text[4];
PDI_expose(&amp;quot;text&amp;quot;, text, PDI_IN);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;write-data-to-flowvr-message-by-copy-to-the-shared-memory&#34;&gt;Write data to FlowVR message by copy to the shared memory&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  text: {type: array, subtype: char, size: 4}

...
    output_ports:
      text:
        data: text
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;char text[4];
PDI_expose(&amp;quot;text&amp;quot;, text, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;write-data-to-flowvr-message-by-copy-the-subset-of-data-to-the-shared-memory&#34;&gt;Write data to FlowVR message by copy the subset of data to the shared memory&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  my_array: {type: array, subtype: int, size: [20, 20]}

...
    output_ports:
      text:
        data: my_array
        copy_data_selection: {type: array, subtype: int, size: [20, 20], subsize: [10, 10], start: [0, 0]}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int my_array[400];
PDI_expose(&amp;quot;my_array&amp;quot;, my_array, PDI_OUT); // copies only 100 elements
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;and-writing-stamps-examples&#34;&gt;and writing stamps examples&lt;/h2&gt;
&lt;p&gt;Stamps are always copied from descriptor to flowvr message.&lt;/p&gt;
&lt;h3 id=&#34;read-stamp-from-flowvr-message&#34;&gt;Read stamp from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  stamp_it: int
...
    input_ports:
      text:
        stamps:
          it: stamp_it
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int stamp_it = some_value;
PDI_expose(&amp;quot;stamp_it&amp;quot;, &amp;amp;stamp_it, PDI_IN);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;write-stamp-from-flowvr-message&#34;&gt;Write stamp from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  user_stamp: int

...
    output_ports:
      text:
        stamps:
          user_defined_stamp: user_stamp
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int user_stamp = some_value;
PDI_expose(&amp;quot;user_stamp&amp;quot;, &amp;amp;user_stamp, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reading-and-writing-mouse-and-button-event-examples&#34;&gt;Reading and writing mouse and button event examples&lt;/h2&gt;
&lt;h3 id=&#34;write-mouse-event-from-flowvr-message&#34;&gt;Write mouse event from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  pos_xy: {type: array, subtype: float, size: 2}
  left_button: int

...
    output_ports:
      keysOut:
        event_mouse:
          POS_XY: pos_xy
          LEFT_BUTTON: left_button
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;float pos_xy[2] = {x_pos, y_pos};
PDI_expose(&amp;quot;pos_xy&amp;quot;, &amp;amp;pos_xy, PDI_OUT);

int left_button = 1;
PDI_expose(&amp;quot;left_button&amp;quot;, &amp;amp;left_button, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;read-mouse-event-from-flowvr-message&#34;&gt;Read mouse event from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  pos_xy: {type: array, subtype: float, size: 2}
  left_button: int

...
input_ports:
  keysIn:
    event_mouse:
      POS_XY: pos_xy
      LEFT_BUTTON: left_button
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;float pos_xy;
PDI_expose(&amp;quot;pos_xy&amp;quot;, &amp;amp;pos_xy, PDI_IN);

int left_button;
PDI_expose(&amp;quot;left_button&amp;quot;, &amp;amp;left_button, PDI_IN);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;write-button-event-from-flowvr-message&#34;&gt;Write button event from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  up: int
  down: int

...
    output_ports:
      keysOut:
        event_button:
          KEY_UP: up
          KEY_DOWN: down
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int up_state = 1;
PDI_expose(&amp;quot;up&amp;quot;, &amp;amp;up_state, PDI_OUT);

int down_state = 1;
PDI_expose(&amp;quot;down&amp;quot;, &amp;amp;down_state, PDI_OUT);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;read-button-event-from-flowvr-message&#34;&gt;Read button event from FlowVR message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;data:
  up: int
  down: int

...
    input_ports:
      keysIn:
        event_button:
          KEY_UP: up
          KEY_DOWN: down
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;int up_state;
PDI_expose(&amp;quot;up&amp;quot;, &amp;amp;up_state, PDI_IN);

int down_state;
PDI_expose(&amp;quot;down&amp;quot;, &amp;amp;down_state, PDI_IN);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;flowvr-examples-reworked-for-pdi&#34;&gt;FlowVR examples reworked for %PDI&lt;/h2&gt;
&lt;p&gt;Path to the examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdi/build/pdi_plugin-flowvr/src/FLOWVR_PLUGIN-build/examples/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Original flowvr source files are in directories &lt;code&gt;flowvr_original&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;running-the-application&#34;&gt;Running the application&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Go to examples folder: &lt;code&gt;cd pdi_plugin-flowvr/src/FLOWVR_PLUGIN-build/examples&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;source flowvr-config.sh&lt;/code&gt;. Now your environment is ready.&lt;/li&gt;
&lt;li&gt;Run flowvr daemon on your system (best in new terminal, repeat 1. and 2.): &lt;code&gt;flowvrd --top&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Inside &lt;code&gt;$example_name&lt;/code&gt; directory generate the flowvr configuration files by: &lt;code&gt;python $example_name.py&lt;/code&gt; and run example by: &lt;code&gt;flowvr $example_name&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tictac-example&#34;&gt;Tictac example&lt;/h3&gt;
&lt;p&gt;Consists of 2 modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;put&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;put.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;put.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;output port&lt;/code&gt; named &lt;code&gt;text&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data: &lt;code&gt;type: {type: array, subtype: char, size: 4} #&amp;quot;tic&amp;quot; or &amp;quot;tac&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stamps:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it (predefined flowvr stamp): &lt;code&gt;type: int&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;my_stamp (user define int array stamp): &lt;code&gt;type: {type: array, subtype: int, size: 2}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;get.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;get.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;input port&lt;/code&gt; named &lt;code&gt;text&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;receive message sent by &lt;code&gt;put&lt;/code&gt; module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;additionally has defined &lt;code&gt;stamp&lt;/code&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;source (predefined flowvr stamp): &lt;code&gt;type: {type: array, subtype: char, size: 256}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Network of the application:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/tictac_net.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;bundle-example&#34;&gt;Bundle example&lt;/h4&gt;
&lt;p&gt;Consists of 3 modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2x &lt;code&gt;putMulitple&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;putMulitple.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;putMulitple.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;first one has &lt;code&gt;output port&lt;/code&gt; named &lt;code&gt;text&lt;/code&gt;, second &lt;code&gt;text2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data: &lt;code&gt;type: {type: array, subtype: char, size: 4} # first &amp;quot;tic&amp;quot; or &amp;quot;tac&amp;quot;, second &amp;quot;TIC&amp;quot; or &amp;quot;TAC&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stamps:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;it&lt;/code&gt; (predefined flowvr stamp): &lt;code&gt;type: int&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getMulitple&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;getMulitple.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;getMulitple.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;input ports&lt;/code&gt; named &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;text2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;receive message sent by &lt;code&gt;putMulitple&lt;/code&gt; modules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;additionally has defined &lt;code&gt;stamp&lt;/code&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;source (predefined flowvr stamp): &lt;code&gt;type: {type: array, subtype: char, size: 256}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Network of the application:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/bundle_net.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;primes-example&#34;&gt;Primes example&lt;/h3&gt;
&lt;p&gt;Consists of 3 modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;capture&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;capture.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;capture.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;output port&lt;/code&gt; named &lt;code&gt;keysOut&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;event_button&lt;/code&gt; (payload):&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KEY_UP: up&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KEY_DOWN: down&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KEY_LEFT: left&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KEY_RIGHT: right&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;compute&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;compute.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;compute.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;output port&lt;/code&gt; named &lt;code&gt;primesOut&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data (payload): &lt;code&gt;type: {type: array, subtype: int, size: $tempPrimeNumbersMaxCount}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stamps:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;computationTimeIt: &lt;code&gt;type: int&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;visu&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source file: &lt;code&gt;visu.cxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;configuration file: &lt;code&gt;visu.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;has &lt;code&gt;input ports&lt;/code&gt; named &lt;code&gt;primesIn&lt;/code&gt; and &lt;code&gt;keysIn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;receive message sent by &lt;code&gt;capture&lt;/code&gt; and &lt;code&gt;compute&lt;/code&gt; modules&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Network of the application:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/primes_net.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;fluid-example&#34;&gt;Fluid example&lt;/h3&gt;
&lt;p&gt;Consists of 2 modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fluid&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;fluid.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;fluid.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;input port&lt;/code&gt; named &lt;code&gt;position&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;received message sent by &lt;code&gt;gldens&lt;/code&gt; module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;output ports&lt;/code&gt; named &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;density&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;density&lt;/code&gt; both sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data (payload): &lt;code&gt;type: {type: array, subtype: char, size: [$NX * 2, $NY]} # where NX and NY is metadata&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stamps:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P: &lt;code&gt;type: {type: array, subtype: int, size: 2}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N: &lt;code&gt;type: {type: array, subtype: int, size: 2}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gldens&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source file: &lt;code&gt;gldens.cxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configuration file: &lt;code&gt;gldens.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;input ports&lt;/code&gt; named &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;density&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;received message sent by &lt;code&gt;fluid&lt;/code&gt; module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has &lt;code&gt;output port&lt;/code&gt; named &lt;code&gt;position&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sends message with:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data (payload): &lt;code&gt;type: {type: array, subtype: float, size: 3}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;very important is how to get a number of elements received by &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;density&lt;/code&gt; ports:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type: {type: array, subtype: char, size: $velocitySize} # velocitySize is defined as metadata&lt;/code&gt; Here &lt;code&gt;velocitySize&lt;/code&gt; must be preceded with &lt;code&gt;$&lt;/code&gt; to let plugin to write the size there. The &lt;code&gt;velocitySize&lt;/code&gt; descriptor will store a valid size &lt;strong&gt;after&lt;/strong&gt; accessing the &lt;code&gt;velocity&lt;/code&gt; descriptor, because only then plugin will write size.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Network of the application:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pdi.julien-bigot.fr/new-site/docs/imgs/fluid_net.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: The user-code plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/user_code_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/user_code_plugin/</guid>
      <description>
        
        
        &lt;p&gt;The &lt;code&gt;user-code&lt;/code&gt; plugin enables one to call a user-defined function when a specified event occur or certain data becomes available.&lt;/p&gt;
&lt;h2 id=&#34;important-notes&#34;&gt;Important notes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Make sure to compile your program with &lt;code&gt;Wl,--export-dynamic&lt;/code&gt; or &lt;code&gt;-rdynamic&lt;/code&gt; flag (in CMake set &lt;code&gt;ENABLE_EXPORTS&lt;/code&gt; to &lt;code&gt;TRUE&lt;/code&gt; using &lt;code&gt;set_target_properties&lt;/code&gt; command) in order to generate necessary symbols.&lt;/li&gt;
&lt;li&gt;Make sure you use the proper access rights in your function in &lt;a href=&#34;member:group__annotation_1ga8dcd0c81d7697ea473a55bd57efb717d&#34;&gt;PDI_access&lt;/a&gt; (PDI_IN for reading, PDI_OUT for writing).&lt;/li&gt;
&lt;li&gt;Descriptor aliases enables one to use different descriptors without the need to recompile the code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dependencies-between-the-code-and-the-specification-tree&#34;&gt;Dependencies between the code and the specification tree&lt;/h2&gt;
&lt;p&gt;To ensure proper work of the &lt;code&gt;user-code&lt;/code&gt; plugin, there are several conventions to follow in the application code and the specification tree.&lt;/p&gt;
&lt;p&gt;First, each function name in specification tree must be a valid function name (watch out for &lt;a href=&#34;https://en.wikipedia.org/wiki/Name_mangling&#34;&gt;name mangling&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Second, these functions &lt;strong&gt;can not&lt;/strong&gt; take any arguments or return any value (i.e. their type must be &lt;code&gt;void(void)&lt;/code&gt;). Use descriptors for passing input/output variables instead.&lt;/p&gt;
&lt;p&gt;Third, function&#39;s symbols &lt;strong&gt;must&lt;/strong&gt; be exported to make them accessible by &lt;code&gt;user-code&lt;/code&gt; plugin. To do this, compile your program as described in &lt;a href=&#34;member:user_code_plugin_1important_notes_node&#34;&gt;Important notes&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;use-examples&#34;&gt;Use examples&lt;/h2&gt;
&lt;p&gt;This section shows a simple examples with the use of a &lt;code&gt;user-code&lt;/code&gt; plugin.&lt;/p&gt;
&lt;h3 id=&#34;hello-world&#34;&gt;Hello world!&lt;/h3&gt;
&lt;p&gt;First, we will call simple function without the use of descriptors to print &amp;quot;Hello world!&amp;quot; on &amp;quot;print&amp;quot; event.&lt;/p&gt;
&lt;p&gt;hello_world.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pdi.h&amp;gt;

void hello_world(void)
{
    printf(&amp;quot;Hello world!\n&amp;quot;);
}

int main(int argc, char* argv[])
{
    PC_tree_t conf = PC_parse_path(&amp;quot;hello_world.yml&amp;quot;);
    PDI_init(conf);
    PDI_event(&amp;quot;print&amp;quot;);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hello_world.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins:
    user_code:
        on_event:
            print:
                hello_world: {}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][User-code][13:40:55] *** info: Plugin loaded successfully
[PDI][13:40:55] *** info: Initialization successful
Hello world!
[PDI][13:40:55] *** info: Finalization
[PDI][User-code][13:40:55] *** info: Closing plugin
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;handling-input&#34;&gt;Handling input&lt;/h3&gt;
&lt;p&gt;Now we will pass some input data to the function.&lt;/p&gt;
&lt;p&gt;print_number.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pdi.h&amp;gt;

void print_number(void)
{
    void* input; PDI_access(&amp;quot;input&amp;quot;, &amp;amp;input, PDI_IN);
    printf(&amp;quot;I&#39;ve got number %d.\n&amp;quot;, *((int*)input));
    PDI_release(&amp;quot;input&amp;quot;);
}

int main(int argc, char* argv[])
{
    PC_tree_t conf = PC_parse_path(&amp;quot;print_number.yml&amp;quot;);
    PDI_init(conf);
    int number = 42;
    PDI_share(&amp;quot;number&amp;quot;, &amp;amp;number, PDI_OUT);
    PDI_event(&amp;quot;print&amp;quot;);
    PDI_reclaim(&amp;quot;number&amp;quot;);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;print_number.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
    number: int
plugins:
    user_code:
        on_event:
            print:
                print_number: {input: $number}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][User-code][13:49:30] *** info: Plugin loaded successfully
[PDI][13:49:30] *** info: Initialization successful
I&#39;ve got number 42.
[PDI][13:49:30] *** info: Finalization
[PDI][User-code][13:49:30] *** info: Closing plugin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can simplify this example by using &lt;code&gt;on_data&lt;/code&gt; to print value of number when it is shared to PDI.&lt;/p&gt;
&lt;p&gt;print_number.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pdi.h&amp;gt;

void print_number(void)
{
    void* input; PDI_access(&amp;quot;input&amp;quot;, &amp;amp;input, PDI_IN);
    printf(&amp;quot;I&#39;ve got number %d.\n&amp;quot;, *((int*)input));
    PDI_release(&amp;quot;input&amp;quot;);
}

int main(int argc, char* argv[])
{
    PC_tree_t conf = PC_parse_path(&amp;quot;print_number.yml&amp;quot;);
    PDI_init(conf);
    int number = 42;
    PDI_expose(&amp;quot;number&amp;quot;, &amp;amp;number, PDI_OUT);
    //PDI_event is no longer necessary and PDI_share/PDI_reclaim can be simplified to PDI_expose
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;print_number.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
    number: int
plugins:
    user_code:
        on_data:
            number:
                print_number: {input: $number}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output does not change:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][User-code][13:52:15] *** info: Plugin loaded successfully
[PDI][13:52:15] *** info: Initialization successful
I&#39;ve got number 42.
[PDI][13:52:15] *** info: Finalization
[PDI][User-code][13:52:15] *** info: Closing plugin
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;handling-output&#34;&gt;Handling output&lt;/h3&gt;
&lt;p&gt;Output handling is very similar to the input handling, the only difference are the access rights. In this example we will call &lt;code&gt;add_ten&lt;/code&gt; function when &lt;code&gt;number&lt;/code&gt; is shared to PDI.&lt;/p&gt;
&lt;p&gt;adding_to_number.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pdi.h&amp;gt;

void add_ten(void)
{
    void* input; PDI_access(&amp;quot;input&amp;quot;, &amp;amp;input, PDI_OUT);
    *((int*)input) += 10;
    PDI_release(&amp;quot;input&amp;quot;);
}

int main(int argc, char* argv[])
{
    PC_tree_t conf = PC_parse_path(&amp;quot;adding_to_number.yml&amp;quot;);
    PDI_init(conf);
    int number = 42;
    printf(&amp;quot;Before expose, number = %d.\n&amp;quot;, number);
    PDI_expose(&amp;quot;number&amp;quot;, &amp;amp;number, PDI_IN);
    printf(&amp;quot;After expose, number = %d.\n&amp;quot;, number);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;adding_to_number.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
    number: int
plugins:
    user_code:
        on_data:
            number:
                add_ten: {input: $number}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][User-code][13:53:51] *** info: Plugin loaded successfully
[PDI][13:53:51] *** info: Initialization successful
Before expose, number = 42.
After expose, number = 52.
[PDI][13:53:51] *** info: Finalization
[PDI][User-code][13:53:51] *** info: Closing plugin
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;multiple-inputoutput-data&#34;&gt;Multiple input/output data&lt;/h3&gt;
&lt;p&gt;In this example we will use multiple data in function. We will add and multiply two given numbers and return the results on event &amp;quot;calculate&amp;quot;.&lt;/p&gt;
&lt;p&gt;calculate.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pdi.h&amp;gt;

void sum_and_multiply(void)
{
    void* number1; PDI_access(&amp;quot;number1&amp;quot;, &amp;amp;number1, PDI_IN);
    void* number2; PDI_access(&amp;quot;number2&amp;quot;, &amp;amp;number2, PDI_IN);
    void* sum;     PDI_access(&amp;quot;sum&amp;quot;, &amp;amp;sum, PDI_OUT);
    void* product; PDI_access(&amp;quot;product&amp;quot;, &amp;amp;product, PDI_OUT);
    *((int*)sum) = *((int*)number1) + *((int*)number2);
    *((int*)product) = *((int*)number1) * *((int*)number2);
    PDI_release(&amp;quot;number1&amp;quot;);
    PDI_release(&amp;quot;number2&amp;quot;);
    PDI_release(&amp;quot;sum&amp;quot;);
    PDI_release(&amp;quot;product&amp;quot;);
}

int main(int argc, char* argv[])
{
    PC_tree_t conf = PC_parse_path(&amp;quot;calculate.yml&amp;quot;);
    PDI_init(conf);
    int foo = 4, bar = 5, res1 = 0, res2 = 0;
    printf(&amp;quot;Before calculation, foo = %d, bar = %d, res1 = %d, res2 = %d.\n&amp;quot;, foo, bar, res1, res2);
    PDI_multi_expose(&amp;quot;calculate&amp;quot;,
        &amp;quot;foo&amp;quot;, &amp;amp;foo, PDI_OUT,
        &amp;quot;bar&amp;quot;, &amp;amp;bar, PDI_OUT,
        &amp;quot;res1&amp;quot;, &amp;amp;res1, PDI_IN,
        &amp;quot;res2&amp;quot;, &amp;amp;res2, PDI_IN, NULL);
    printf(&amp;quot;After calculation, foo = %d, bar = %d, res1 = %d, res2 = %d.\n&amp;quot;, foo, bar, res1, res2);
    PDI_finalize();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;calculate.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data:
    foo: int
    bar: int
    res1: int
    res2: int
plugins:
    user_code:
        on_event:
            calculate:
                sum_and_multiply: {number1: $foo, number2: $bar, sum: $res1, product: $res2}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][User-code][13:58:20] *** info: Plugin loaded successfully
[PDI][13:58:20] *** info: Initialization successful
Before calculation, foo = 4, bar = 5, res1 = 0, res2 = 0.
After calculation, foo = 4, bar = 5, res1 = 9, res2 = 20.
[PDI][13:58:20] *** info: Finalization
[PDI][User-code][13:58:20] *** info: Closing plugin
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;configuration-grammar&#34;&gt;Configuration grammar&lt;/h2&gt;
&lt;p&gt;The root of &lt;code&gt;user-code&lt;/code&gt; plugin is a dictionary that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;on_data&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:user_code_plugin_1on_data_node&#34;&gt;on_data&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;on_event&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:user_code_plugin_1on_event_node&#34;&gt;on_event&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;anything&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;on_data&lt;/code&gt; key specifies the list of descriptors that, when they become available, will cause the specified functions to be called,&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;on_event&lt;/code&gt; key specifies the list of events on which to call the specified functions,&lt;/li&gt;
&lt;li&gt;additional keys are ignored.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;on_data&#34;&gt;on_data&lt;/h3&gt;
&lt;p&gt;A &lt;a href=&#34;member:user_code_plugin_1on_data_node&#34;&gt;on_data&lt;/a&gt; is a dictionary that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:user_code_plugin_1function_list_node&#34;&gt;function_list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a descriptor, which will trigger specified functions when it becomes available.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;on_event&#34;&gt;on_event&lt;/h3&gt;
&lt;p&gt;A &lt;a href=&#34;member:user_code_plugin_1on_event_node&#34;&gt;on_event&lt;/a&gt; is a dictionary that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:user_code_plugin_1function_list_node&#34;&gt;function_list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of an event, which will trigger specified functions when it occurs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;function_list&#34;&gt;function_list&lt;/h3&gt;
&lt;p&gt;A &lt;a href=&#34;member:user_code_plugin_1function_list_node&#34;&gt;function_list&lt;/a&gt; is a dictionary that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a &lt;a href=&#34;member:user_code_plugin_1function_param_list_node&#34;&gt;function_param_list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a function, which will be called on specified event or data,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: these functions &lt;strong&gt;can not&lt;/strong&gt; take any arguments or return any value (i.e. their type must be &lt;code&gt;void(void)&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;function_param_list&#34;&gt;function_param_list&lt;/h3&gt;
&lt;p&gt;A &lt;a href=&#34;member:user_code_plugin_1function_param_list_node&#34;&gt;function_param_list&lt;/a&gt; is a dictionary that contains the following keys:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.*&amp;quot;&lt;/code&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;a $-expression referencing a data&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;each key identifies the name of a descriptor alias, which will be available during function execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;specification-tree-example&#34;&gt;Specification tree example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;data:
    desc1: int
    desc2: float
    desc3: double
plugins:
    user_code:
        on_data:
            desc1:
                fun1: {in: $desc2, out: $desc3}
            desc2:
                fun2: {}
                fun3: {out: $desc2}
        on_event:
            event1:
                fun2: {}
            event2:
                fun4: {param1: $desc2, param2: $desc1, param3: $desc3}
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Trace plugin</title>
      <link>http://pdi.julien-bigot.fr/new-site/docs/trace_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pdi.julien-bigot.fr/new-site/docs/trace_plugin/</guid>
      <description>
        
        
        &lt;p&gt;The trace plugin is intended to generate a trace of what happens in &lt;a href=&#34;member:Concepts_1Data_store&#34;&gt;PDI data store&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The plugin is very simple; just list its name in the &lt;a href=&#34;member:Concepts_1Specification_tree&#34;&gt;specification tree&lt;/a&gt; and you&#39;re done.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: #...
metadata: #...
plugins:
  trace:
  #...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The plugin then generates a (somewhat verbose) trace on the standard error.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PDI][Test-plugin][00:00:00] *** info: Welcome!
[PDI][Test-plugin][00:00:00] *** info: =&amp;gt;&amp;gt;   data becoming available in the store: my_data
[PDI][Test-plugin][00:00:00] *** info: &amp;lt;&amp;lt;= data stop being available in the store: my_data
[PDI][Test-plugin][00:00:00] *** info: !!!                            named event: my_event
[PDI][Test-plugin][00:00:00] *** info: Goodbye!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each line starting by &lt;code&gt;=&amp;gt;&amp;gt; data becoming available in the store&lt;/code&gt; means a new piece of data has been shared.&lt;/p&gt;
&lt;p&gt;Each line starting by &lt;code&gt;&amp;lt;&amp;lt;= data stop being available in the store&lt;/code&gt; means a piece of data is being removed from the store.&lt;/p&gt;
&lt;p&gt;Each line starting by &lt;code&gt;!!! named event&lt;/code&gt; means a named event has been emitted.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
