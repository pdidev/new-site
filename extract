#!/bin/env python3

import os.path
import shutil
import re
import sys
import textwrap
import xml.etree.ElementTree as ET
import doxmd

current_page=''

def page_name_mangle(kind, name):
    current_page = re.sub(r'[^a-zA-Z0-9]', '_', name)
    if current_page == 'index':
        current_page='_index'
    elif kind != 'page':
        current_page = kind+'/'+current_page
    elif current_page.endswith('_plugin'):
        current_page = 'plugin/'+current_page[:-7]
    elif current_page == 'Plugins':
        current_page = 'plugin/_index'
    return '/docs/'+current_page+'.md'


def node_contains(node, path):
    if node is None: return False
    subnode = node.find(path)
    if subnode is None: return False
    if len(subnode) > 0: return True
    text = subnode.text
    if text is None: return False
    if text.strip() == '': return False
    return True



def generate_page_anchors(node, ret):
    if node.get('kind') in [ 'file' ]:
        return ret
    kind = node.get('kind')
    if kind == 'struct': kind = 'class'
    current_page = page_name_mangle(kind, node.findtext('compoundname'))
    if node.get('id') is not None:
        ret['compound:'+node.get('id')] = current_page
    for e in node:
        ret = generate_anchors(e, current_page, "#", ret)
    return ret


def generate_anchors(node, current_page, current_anchor, ret):
    if node.tag[:-1] == 'sect':
        current_anchor = '#'+re.sub(r'[^a-z0-9]+', '-', node.findtext('title').lower())
    if node.get('id') is not None:
        ret['member:'+node.get('id')] = current_page + current_anchor
    for e in node:
        ret = generate_anchors(e, current_page, current_anchor, ret)
    return ret



def compounddef_to_md(node):
    global current_page
    kind = node.get('kind')
    if kind == 'struct': kind = 'class'
    current_page = "content"+page_name_mangle(kind, node.findtext('compoundname'))
    os.makedirs(os.path.dirname(current_page), exist_ok=True)
    if not os.path.isfile(os.path.join(os.path.dirname(current_page), "_index.md")):
        with open(os.path.join(os.path.dirname(current_page), "_index.md"), mode='w') as out:
            print("---", file=out)
            print("title: "+os.path.basename(os.path.dirname(current_page)).capitalize()+" list", file=out)
            print("weight: 300", file=out)
            print("---", file=out)
    with open(current_page, mode='w') as out:
        if kind == 'page':
            print(compounddef_to_md_page(node), file=out)
        elif kind == 'class':
            #print(compounddef_to_md_class(node), file=out)
            pass
        else:
            print("---", file=out)
            print("title: >-", file=out)
            if node.findtext('title') is not None:
                print(textwrap.indent(node.findtext('title'), "  "), file=out)
            else:
                print(textwrap.indent(node.findtext('compoundname'), "  "), file=out)
            print("---", file=out)
            #print("Unhandled compounddefType["
                #+ ", ".join(["@"+t+"='"+v+"'" for t, v in node.items()])
                #+ "]")
            #for e in node:
                #print("  ."+e.tag)


def compounddef_to_md_page(node):
    return doxmd.compounddef_to_md_page(node)
    ret = ""
    ret += "---\n"
    ret += "title: >-\n"
    if node.findtext('title') is not None:
        ret += textwrap.indent(node.findtext('title'), "  ")+"\n"
    else:
        ret += textwrap.indent(node.findtext('compoundname'), "  ")+"\n"
    if node.findtext('briefdescription') is not None and len(node.findtext('briefdescription').strip())>0:
            ret += "description: >"
            ret += textwrap.indent(description_to_md(node.find('briefdescription')).strip(), '  ')+"\n"
    
    if current_page == 'content/docs/_index.md':
        ret +="""\
linkTitle: "Documentation"
weight: 20
menu: { main: { weight: 20 } }
"""
    if node.findtext('compoundname') == 'Plugins':
        ret +="weight: 200\n"
    else:
        ret +="weight: 100\n"
    
    ret += "---\n"
    ret += description_to_md(node.find('detaileddescription'))
    return ret


def compounddef_to_md_class(node):
    ret = ""
    ret += "---\n"
    if node.findtext('title') is not None:
        ret += "title: >-\n" + textwrap.indent(node.findtext('title'), "  ")+" class reference\n"
        ret += "linkTitle: >-\n" + textwrap.indent(node.findtext('title'), "  ")+"\n"
    else:
        ret += "title: >-\n" + textwrap.indent(node.findtext('compoundname'), "  ")+" class reference\n"
        ret += "linkTitle: >-\n" + textwrap.indent(node.findtext('compoundname'), "  ")+"\n"
    ret += "---\n"
    if node_contains(node, 'briefdescription'):
        ret += description_to_md(node.find('briefdescription')).strip()+' [More...](#detailed-description)\n\n'
    if node_contains(node, 'detaileddescription'):
        ret += '## Detailed Description\n'
        ret += description_to_md(node.find('detaileddescription')).strip()+'\n'
    if node_contains(node, 'sectiondef[@kind=\'public-func\']'):
        ret +="## Constructors & desctructors\n"+ sectiondef_to_md_cst_lst(node.find('sectiondef[@kind=\'public-func\']'))+'\n'
    if node_contains(node, 'sectiondef[@kind=\'public-func\']'):
        ret +="## Public functions\n"+ sectiondef_to_md_lst(node.find('sectiondef[@kind=\'public-func\']'))+'\n'
    for e in node.findall('sectiondef'):
        ret += sectiondef_to_md(e).strip()+'\n'
    for e in node:
        if e.tag in [ 'compoundname', 'id', 'briefdescription', 'listofallmembers' ]:
            pass
        else:
            print("unknown tag: "+e.tag)
    return ret



def doc_cmd_group_to_md(e):
    ret = doc_title_cmd_group_to_md(e)
    if ret is not None:
        return ret
    elif e.tag == 'hruler':
        return '\n---\n'
      #<xsd:element name="preformatted" type="docMarkupType" />
    elif e.tag == 'programlisting':
        return listing_to_md(e)
      #<xsd:element name="verbatim" type="xsd:string" />
      #<xsd:element name="indexentry" type="docIndexEntryType" />
    elif e.tag == 'orderedlist':
        return doc_list_to_md_ordered(e)
    elif e.tag == 'itemizedlist':
        return doc_list_to_md_unordered(e)
    elif e.tag == 'simplesect':
        return doc_simple_sect_to_md(e)
      #<xsd:element name="title" type="docTitleType" />
    elif e.tag == 'variablelist':
        return doc_variable_list_to_md(e)
    elif e.tag == 'table':
        return doc_table_to_md(e)
      #<xsd:element name="heading" type="docHeadingType" />
      #<xsd:element name="dotfile" type="docImageType" />
      #<xsd:element name="mscfile" type="docImageType" />
      #<xsd:element name="diafile" type="docImageType" />
      #<xsd:element name="toclist" type="docTocListType" />
      #<xsd:element name="language" type="docLanguageType" />
    elif e.tag == 'parameterlist':
        return doc_param_list_to_md(e)
      #<xsd:element name="xrefsect" type="docXRefSectType" />
      #<xsd:element name="copydoc" type="docCopyType" />
      #<xsd:element name="blockquote" type="docBlockQuoteType" />
      #<xsd:element name="parblock" type="docParBlockType" />
    return None


def doc_markup_to_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        ret += doc_cmd_group_to_md(e)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_param_list_to_md(node):
    ret = "#### Parameters:"
    for e in node:
        if e.tag == 'parameteritem':
            ret += doc_param_list_item_to_md(e)
        else:
            print("unknown tag in docParamListType: "+e.tag)
    return ret


def doc_param_name_list_to_md(node):
    ret = ""
    for e in node:
        if e.tag == 'parametertype':
            ret += linked_text_to_tt_md(e)
        elif e.tag == 'parametername':
            ret += linked_text_to_tt_md(e)
        else:
            print("unknown tag in docParamNameList: "+e.tag)
    return ret


def doc_param_list_item_to_md(node):
    ret = "\n"
    
    for e in node:
        if e.tag == 'parameternamelist':
            ret += doc_param_name_list_to_md(e).strip()+'\n'
        elif e.tag == 'parameterdescription':
            ret += ':   '+ textwrap.indent(description_to_md(e).strip(), '    ')[1:]+'\n'
        else:
            print("unknown tag in docParamListItem: "+e.tag)
    return ret


def doc_ref_text_to_md(node):
    ret = "["
    if node.text is not None:
        ret += node.text
    for e in node:
        grp = doc_title_cmd_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    ret += "]({{< ref \""+node.get('kindref')+':'+node.get('refid')+"\" >}})"
    return ret


def doc_title_cmd_group_to_md(e):
    if e.tag == 'ulink':
        return doc_url_link_to_md(e)
    elif e.tag == 'bold':
        return "**" + doc_markup_to_md(e) + "**"
    elif e.tag == 'strike':
        return "-" + doc_markup_to_md(e) + "-"
    elif e.tag == 'underline':
        return "_" + doc_markup_to_md(e) + "_"
    elif e.tag == 'emphasis':
        return "*" + doc_markup_to_md(e) + "*"
    elif e.tag == 'computeroutput':
        return "`" + doc_markup_to_md(e) + "`"
      #<xsd:element name="subscript" type="docMarkupType" />
      #<xsd:element name="superscript" type="docMarkupType" />
      #<xsd:element name="center" type="docMarkupType" />
      #<xsd:element name="small" type="docMarkupType" />
      #<xsd:element name="del" type="docMarkupType" />
      #<xsd:element name="inc" type="docMarkupType" />
      #<xsd:element name="htmlonly" type="docHtmlOnlyType" />
      #<xsd:element name="manonly" type="xsd:string" />
      #<xsd:element name="xmlonly" type="xsd:string" />
      #<xsd:element name="rtfonly" type="xsd:string" />
      #<xsd:element name="latexonly" type="xsd:string" />
    elif e.tag == 'image':
        return doc_image_to_md(e)
      #<xsd:element name="dot" type="docImageType" />
      #<xsd:element name="msc" type="docImageType" />
      #<xsd:element name="plantuml" type="docImageType" />
      #<xsd:element name="anchor" type="docAnchorType" />
    elif e.tag == 'anchor':
        return doc_anchor_to_md(e)
      #<xsd:element name="formula" type="docFormulaType" />
    elif e.tag == 'ref':
        return doc_ref_text_to_md(e)
      #<xsd:element name="emoji" type="docEmojiType" />
    elif e.tag == 'linebreak':
        return "  \n"
      #<xsd:element name="nonbreakablespace" type="docEmptyType" />
      #<xsd:element name="iexcl" type="docEmptyType" />
      #<xsd:element name="cent" type="docEmptyType" />
      #<xsd:element name="pound" type="docEmptyType" />
      #<xsd:element name="curren" type="docEmptyType" />
      #<xsd:element name="yen" type="docEmptyType" />
      #<xsd:element name="brvbar" type="docEmptyType" />
      #<xsd:element name="sect" type="docEmptyType" />
      #<xsd:element name="umlaut" type="docEmptyType" />
      #<xsd:element name="copy" type="docEmptyType" />
      #<xsd:element name="ordf" type="docEmptyType" />
      #<xsd:element name="laquo" type="docEmptyType" />
      #<xsd:element name="not" type="docEmptyType" />
      #<xsd:element name="shy" type="docEmptyType" />
      #<xsd:element name="registered" type="docEmptyType" />
      #<xsd:element name="macr" type="docEmptyType" />
      #<xsd:element name="deg" type="docEmptyType" />
      #<xsd:element name="plusmn" type="docEmptyType" />
      #<xsd:element name="sup2" type="docEmptyType" />
      #<xsd:element name="sup3" type="docEmptyType" />
      #<xsd:element name="acute" type="docEmptyType" />
      #<xsd:element name="micro" type="docEmptyType" />
      #<xsd:element name="para" type="docEmptyType" />
      #<xsd:element name="middot" type="docEmptyType" />
      #<xsd:element name="cedil" type="docEmptyType" />
      #<xsd:element name="sup1" type="docEmptyType" />
      #<xsd:element name="ordm" type="docEmptyType" />
      #<xsd:element name="raquo" type="docEmptyType" />
      #<xsd:element name="frac14" type="docEmptyType" />
      #<xsd:element name="frac12" type="docEmptyType" />
      #<xsd:element name="frac34" type="docEmptyType" />
      #<xsd:element name="iquest" type="docEmptyType" />
      #<xsd:element name="Agrave" type="docEmptyType" />
      #<xsd:element name="Aacute" type="docEmptyType" />
      #<xsd:element name="Acirc" type="docEmptyType" />
      #<xsd:element name="Atilde" type="docEmptyType" />
      #<xsd:element name="Aumlaut" type="docEmptyType" />
      #<xsd:element name="Aring" type="docEmptyType" />
      #<xsd:element name="AElig" type="docEmptyType" />
      #<xsd:element name="Ccedil" type="docEmptyType" />
      #<xsd:element name="Egrave" type="docEmptyType" />
      #<xsd:element name="Eacute" type="docEmptyType" />
      #<xsd:element name="Ecirc" type="docEmptyType" />
      #<xsd:element name="Eumlaut" type="docEmptyType" />
      #<xsd:element name="Igrave" type="docEmptyType" />
      #<xsd:element name="Iacute" type="docEmptyType" />
      #<xsd:element name="Icirc" type="docEmptyType" />
      #<xsd:element name="Iumlaut" type="docEmptyType" />
      #<xsd:element name="ETH" type="docEmptyType" />
      #<xsd:element name="Ntilde" type="docEmptyType" />
      #<xsd:element name="Ograve" type="docEmptyType" />
      #<xsd:element name="Oacute" type="docEmptyType" />
      #<xsd:element name="Ocirc" type="docEmptyType" />
      #<xsd:element name="Otilde" type="docEmptyType" />
      #<xsd:element name="Oumlaut" type="docEmptyType" />
      #<xsd:element name="times" type="docEmptyType" />
      #<xsd:element name="Oslash" type="docEmptyType" />
      #<xsd:element name="Ugrave" type="docEmptyType" />
      #<xsd:element name="Uacute" type="docEmptyType" />
      #<xsd:element name="Ucirc" type="docEmptyType" />
      #<xsd:element name="Uumlaut" type="docEmptyType" />
      #<xsd:element name="Yacute" type="docEmptyType" />
      #<xsd:element name="THORN" type="docEmptyType" />
      #<xsd:element name="szlig" type="docEmptyType" />
      #<xsd:element name="agrave" type="docEmptyType" />
      #<xsd:element name="aacute" type="docEmptyType" />
      #<xsd:element name="acirc" type="docEmptyType" />
      #<xsd:element name="atilde" type="docEmptyType" />
      #<xsd:element name="aumlaut" type="docEmptyType" />
      #<xsd:element name="aring" type="docEmptyType" />
      #<xsd:element name="aelig" type="docEmptyType" />
      #<xsd:element name="ccedil" type="docEmptyType" />
      #<xsd:element name="egrave" type="docEmptyType" />
      #<xsd:element name="eacute" type="docEmptyType" />
      #<xsd:element name="ecirc" type="docEmptyType" />
      #<xsd:element name="eumlaut" type="docEmptyType" />
      #<xsd:element name="igrave" type="docEmptyType" />
      #<xsd:element name="iacute" type="docEmptyType" />
      #<xsd:element name="icirc" type="docEmptyType" />
      #<xsd:element name="iumlaut" type="docEmptyType" />
      #<xsd:element name="eth" type="docEmptyType" />
      #<xsd:element name="ntilde" type="docEmptyType" />
      #<xsd:element name="ograve" type="docEmptyType" />
      #<xsd:element name="oacute" type="docEmptyType" />
      #<xsd:element name="ocirc" type="docEmptyType" />
      #<xsd:element name="otilde" type="docEmptyType" />
      #<xsd:element name="oumlaut" type="docEmptyType" />
      #<xsd:element name="divide" type="docEmptyType" />
      #<xsd:element name="oslash" type="docEmptyType" />
      #<xsd:element name="ugrave" type="docEmptyType" />
      #<xsd:element name="uacute" type="docEmptyType" />
      #<xsd:element name="ucirc" type="docEmptyType" />
      #<xsd:element name="uumlaut" type="docEmptyType" />
      #<xsd:element name="yacute" type="docEmptyType" />
      #<xsd:element name="thorn" type="docEmptyType" />
      #<xsd:element name="yumlaut" type="docEmptyType" />
      #<xsd:element name="fnof" type="docEmptyType" />
      #<xsd:element name="Alpha" type="docEmptyType" />
      #<xsd:element name="Beta" type="docEmptyType" />
      #<xsd:element name="Gamma" type="docEmptyType" />
      #<xsd:element name="Delta" type="docEmptyType" />
      #<xsd:element name="Epsilon" type="docEmptyType" />
      #<xsd:element name="Zeta" type="docEmptyType" />
      #<xsd:element name="Eta" type="docEmptyType" />
      #<xsd:element name="Theta" type="docEmptyType" />
      #<xsd:element name="Iota" type="docEmptyType" />
      #<xsd:element name="Kappa" type="docEmptyType" />
      #<xsd:element name="Lambda" type="docEmptyType" />
      #<xsd:element name="Mu" type="docEmptyType" />
      #<xsd:element name="Nu" type="docEmptyType" />
      #<xsd:element name="Xi" type="docEmptyType" />
      #<xsd:element name="Omicron" type="docEmptyType" />
      #<xsd:element name="Pi" type="docEmptyType" />
      #<xsd:element name="Rho" type="docEmptyType" />
      #<xsd:element name="Sigma" type="docEmptyType" />
      #<xsd:element name="Tau" type="docEmptyType" />
      #<xsd:element name="Upsilon" type="docEmptyType" />
      #<xsd:element name="Phi" type="docEmptyType" />
      #<xsd:element name="Chi" type="docEmptyType" />
      #<xsd:element name="Psi" type="docEmptyType" />
      #<xsd:element name="Omega" type="docEmptyType" />
      #<xsd:element name="alpha" type="docEmptyType" />
      #<xsd:element name="beta" type="docEmptyType" />
      #<xsd:element name="gamma" type="docEmptyType" />
      #<xsd:element name="delta" type="docEmptyType" />
      #<xsd:element name="epsilon" type="docEmptyType" />
      #<xsd:element name="zeta" type="docEmptyType" />
      #<xsd:element name="eta" type="docEmptyType" />
      #<xsd:element name="theta" type="docEmptyType" />
      #<xsd:element name="iota" type="docEmptyType" />
      #<xsd:element name="kappa" type="docEmptyType" />
      #<xsd:element name="lambda" type="docEmptyType" />
      #<xsd:element name="mu" type="docEmptyType" />
      #<xsd:element name="nu" type="docEmptyType" />
      #<xsd:element name="xi" type="docEmptyType" />
      #<xsd:element name="omicron" type="docEmptyType" />
      #<xsd:element name="pi" type="docEmptyType" />
      #<xsd:element name="rho" type="docEmptyType" />
      #<xsd:element name="sigmaf" type="docEmptyType" />
      #<xsd:element name="sigma" type="docEmptyType" />
      #<xsd:element name="tau" type="docEmptyType" />
      #<xsd:element name="upsilon" type="docEmptyType" />
      #<xsd:element name="phi" type="docEmptyType" />
      #<xsd:element name="chi" type="docEmptyType" />
      #<xsd:element name="psi" type="docEmptyType" />
      #<xsd:element name="omega" type="docEmptyType" />
      #<xsd:element name="thetasym" type="docEmptyType" />
      #<xsd:element name="upsih" type="docEmptyType" />
      #<xsd:element name="piv" type="docEmptyType" />
      #<xsd:element name="bull" type="docEmptyType" />
      #<xsd:element name="hellip" type="docEmptyType" />
      #<xsd:element name="prime" type="docEmptyType" />
      #<xsd:element name="Prime" type="docEmptyType" />
      #<xsd:element name="oline" type="docEmptyType" />
      #<xsd:element name="frasl" type="docEmptyType" />
      #<xsd:element name="weierp" type="docEmptyType" />
      #<xsd:element name="imaginary" type="docEmptyType" />
      #<xsd:element name="real" type="docEmptyType" />
      #<xsd:element name="trademark" type="docEmptyType" />
      #<xsd:element name="alefsym" type="docEmptyType" />
      #<xsd:element name="larr" type="docEmptyType" />
      #<xsd:element name="uarr" type="docEmptyType" />
      #<xsd:element name="rarr" type="docEmptyType" />
      #<xsd:element name="darr" type="docEmptyType" />
      #<xsd:element name="harr" type="docEmptyType" />
      #<xsd:element name="crarr" type="docEmptyType" />
      #<xsd:element name="lArr" type="docEmptyType" />
      #<xsd:element name="uArr" type="docEmptyType" />
      #<xsd:element name="rArr" type="docEmptyType" />
      #<xsd:element name="dArr" type="docEmptyType" />
      #<xsd:element name="hArr" type="docEmptyType" />
      #<xsd:element name="forall" type="docEmptyType" />
      #<xsd:element name="part" type="docEmptyType" />
      #<xsd:element name="exist" type="docEmptyType" />
      #<xsd:element name="empty" type="docEmptyType" />
      #<xsd:element name="nabla" type="docEmptyType" />
      #<xsd:element name="isin" type="docEmptyType" />
      #<xsd:element name="notin" type="docEmptyType" />
      #<xsd:element name="ni" type="docEmptyType" />
      #<xsd:element name="prod" type="docEmptyType" />
      #<xsd:element name="sum" type="docEmptyType" />
      #<xsd:element name="minus" type="docEmptyType" />
      #<xsd:element name="lowast" type="docEmptyType" />
      #<xsd:element name="radic" type="docEmptyType" />
      #<xsd:element name="prop" type="docEmptyType" />
      #<xsd:element name="infin" type="docEmptyType" />
      #<xsd:element name="ang" type="docEmptyType" />
      #<xsd:element name="and" type="docEmptyType" />
      #<xsd:element name="or" type="docEmptyType" />
      #<xsd:element name="cap" type="docEmptyType" />
      #<xsd:element name="cup" type="docEmptyType" />
      #<xsd:element name="int" type="docEmptyType" />
      #<xsd:element name="there4" type="docEmptyType" />
      #<xsd:element name="sim" type="docEmptyType" />
      #<xsd:element name="cong" type="docEmptyType" />
      #<xsd:element name="asymp" type="docEmptyType" />
      #<xsd:element name="ne" type="docEmptyType" />
      #<xsd:element name="equiv" type="docEmptyType" />
      #<xsd:element name="le" type="docEmptyType" />
      #<xsd:element name="ge" type="docEmptyType" />
      #<xsd:element name="sub" type="docEmptyType" />
      #<xsd:element name="sup" type="docEmptyType" />
      #<xsd:element name="nsub" type="docEmptyType" />
      #<xsd:element name="sube" type="docEmptyType" />
      #<xsd:element name="supe" type="docEmptyType" />
      #<xsd:element name="oplus" type="docEmptyType" />
      #<xsd:element name="otimes" type="docEmptyType" />
      #<xsd:element name="perp" type="docEmptyType" />
      #<xsd:element name="sdot" type="docEmptyType" />
      #<xsd:element name="lceil" type="docEmptyType" />
      #<xsd:element name="rceil" type="docEmptyType" />
      #<xsd:element name="lfloor" type="docEmptyType" />
      #<xsd:element name="rfloor" type="docEmptyType" />
      #<xsd:element name="lang" type="docEmptyType" />
      #<xsd:element name="rang" type="docEmptyType" />
      #<xsd:element name="loz" type="docEmptyType" />
      #<xsd:element name="spades" type="docEmptyType" />
      #<xsd:element name="clubs" type="docEmptyType" />
      #<xsd:element name="hearts" type="docEmptyType" />
      #<xsd:element name="diams" type="docEmptyType" />
      #<xsd:element name="OElig" type="docEmptyType" />
      #<xsd:element name="oelig" type="docEmptyType" />
      #<xsd:element name="Scaron" type="docEmptyType" />
      #<xsd:element name="scaron" type="docEmptyType" />
      #<xsd:element name="Yumlaut" type="docEmptyType" />
      #<xsd:element name="circ" type="docEmptyType" />
      #<xsd:element name="tilde" type="docEmptyType" />
      #<xsd:element name="ensp" type="docEmptyType" />
      #<xsd:element name="emsp" type="docEmptyType" />
      #<xsd:element name="thinsp" type="docEmptyType" />
      #<xsd:element name="zwnj" type="docEmptyType" />
      #<xsd:element name="zwj" type="docEmptyType" />
      #<xsd:element name="lrm" type="docEmptyType" />
      #<xsd:element name="rlm" type="docEmptyType" />
      #<xsd:element name="ndash" type="docEmptyType" />
      #<xsd:element name="mdash" type="docEmptyType" />
      #<xsd:element name="lsquo" type="docEmptyType" />
      #<xsd:element name="rsquo" type="docEmptyType" />
      #<xsd:element name="sbquo" type="docEmptyType" />
      #<xsd:element name="ldquo" type="docEmptyType" />
      #<xsd:element name="rdquo" type="docEmptyType" />
      #<xsd:element name="bdquo" type="docEmptyType" />
      #<xsd:element name="dagger" type="docEmptyType" />
      #<xsd:element name="Dagger" type="docEmptyType" />
      #<xsd:element name="permil" type="docEmptyType" />
      #<xsd:element name="lsaquo" type="docEmptyType" />
      #<xsd:element name="rsaquo" type="docEmptyType" />
      #<xsd:element name="euro" type="docEmptyType" />
      #<xsd:element name="tm" type="docEmptyType" />
    return None


def ref_text_to_md(node):

    ret = "["
    if node.text is not None:
        ret += node.text
    try:
        ret += "]({{< ref \""+anchors[node.get('kindref')+':'+node.get('refid')]+"\" >}})"
    except KeyError:
        ret += "](#)"
        print("missing ref : "+node.get('kindref')+':'+node.get('refid'))
    return ret


def ref_text_to_tt_md(node):
    ret = "["
    if node.text is not None:
        ret += '`'+node.text+'`'
    try:
        ret += "]({{< ref \""+anchors[node.get('kindref')+':'+node.get('refid')]+"\" >}})"
    except KeyError:
        ret += "](#)"
        print("missing ref : "+node.get('kindref')+':'+node.get('refid'))
    return ret


def ref_text_to_txt(node):
    return node.text


def sectiondef_to_md(node):
    ret = ''
    kind = node.get('kind')
    if kind == 'public-func':
        ret += '## Member Function Documentation\n'
    elif kind == 'friend':
        ret += '## Friends And Related Function Documentation\n'
    elif kind == 'private-attrib':
        return ''
    else:
        print("Unexpected member kind: "+kind)
        return ''
        
    
    for e in node:
        if e.tag == 'header':
            ret += 'Header: '+e.text+'\n'
        elif e.tag == 'description':
            ret += description_to_md(e)+"\n"
        elif e.tag == 'memberdef':
            ret += memberdef_to_md(e)
        else:
            print("unknown tag in sectiondefType: "+e.tag)
    return ret


def sectiondef_to_md_lst(node):
    ret = ''
    ret += "".join({memberdef_to_md_lst(e).strip()+"\n\n" for e in node.findall('memberdef') if node_contains(e, 'type')})
    return ret


def sectiondef_to_md_cst_lst(node):
    ret = ''
    ret += "".join({memberdef_to_md_lst(e).strip()+"\n\n" for e in node.findall('memberdef') if not node_contains(e, 'type')})
    return ret


def memberdef_to_md(node):
    ret = '### '
    if node.get('virt') in [ 'virtual', 'pure-virtual' ]:
        ret += '`virtual` '
    if node_contains(node, 'type'):
        ret += linked_text_to_tt_md(node.find('type')).strip() + ' '
    ret += linked_text_to_tt_md(node.find('name')).strip() + ' '
    ret += '`(` '
    ret += ", ".join([param_to_md(param).strip() for param in node.findall('param')])
    ret += ' `)`'
    if node.get('virt') == 'pure-virtual':
        ret += ' `=` `0`'
    ret += '\n'
    
    if node_contains(node, 'briefdescription'):
        ret += description_to_md(node.find('briefdescription'))
    if node_contains(node, 'detaileddescription'):
        ret += description_to_md(node.find('detaileddescription'))
    
    for e in node:
        if e.tag in [ 'definition', 'briefdescription', 'detaileddescription', 'type', 'name', 'argsstring' ]:
            pass
        else:
            print("unknown tag in memberdefType: "+e.tag)
    
    return ret+'\n\n'


def memberdef_to_md_lst(node):
    ret = '`'
    if node.get('virt') in [ 'virtual', 'pure-virtual' ]:
        ret += 'virtual '
    if node_contains(node, 'type'):
        ret += linked_text_to_intt_md(node.find('type')).strip() + ' '
    ret += linked_text_to_intt_md(node.find('name')).strip() + ' '
    ret += '( '
    ret += ", ".join([param_to_intt_md(param).strip() for param in node.findall('param')])
    ret += ' )'
    if node.get('virt') == 'pure-virtual':
        ret += ' = 0'
    ret += '`\n: *'
    
    if node_contains(node, 'briefdescription'):
        ret += textwrap.indent(description_to_md(node.find('briefdescription')).strip(), '    ')[1:]
    
    return ret+' More...\n'

def description_to_md(node):
    ret = ''
    if node.findtext('title') is not None:
        ret += "# {node.findtext('title')}\n\n"
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'title':
            pass
        elif e.tag == 'para':
            ret += doc_para_to_md(e)
        elif e.tag == 'sect1':
            ret += doc_sect1_to_md(e)
        else:
            print("unknown tag: "+e.tag)

        if e.tail is not None:
            ret += e.tail
    return ret


def param_to_md(node):
    ret = ''
    if node_contains(node, 'type'):
        ret += linked_text_to_tt_md(node.find('type')).strip() + ' '
    if node_contains(node, 'declname'):
        ret += '`'+node.findtext('declname').strip() + '` '
    return ret


def param_to_intt_md(node):
    ret = ''
    if node_contains(node, 'type'):
        ret += linked_text_to_intt_md(node.find('type')).strip() + ' '
    if node_contains(node, 'declname'):
        ret += node.findtext('declname').strip() + ' '
    return ret


def linked_text_to_tt_md(node):
    ret = ''
    if node.text is not None:
        ret += '`'+node.text+'`'
    for e in node:
        if e.tag == 'ref':
            ret += ref_text_to_tt_md(e).strip()
        else:
            print("unknown tag: "+e.tag)

        if e.tail is not None:
            ret += '`'+e.tail+'`'
    return ret


def linked_text_to_intt_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'ref':
            ret += '`'+ref_text_to_tt_md(e).strip()+'`'
        else:
            print("unknown tag: "+e.tag)

        if e.tail is not None:
            ret += e.tail
    return ret


def linked_text_to_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'ref':
            ret += ref_text_to_md(e)
        else:
            print("unknown tag: "+e.tag)

        if e.tail is not None:
            ret += e.tail
    return ret


def listing_to_md(node):
    ret = ''
    ret += "\n``` "
    if node.get('filename') is not None:
        file, ext = os.path.splitext(node.get('filename'))
        if len(ext)>0 and ext[0] == '.':
            ret += ext[1:]
        elif len(file)>0 and file[0] == '.':
            ret += file[1:]
        else:
            ret += node.get('filename')
    else:
        ret += 'plain'
    ret += " \n"
    for e in node:
        ret += codeline_to_md(e)
        ret += "\n"
    ret += "```\n"
    return ret


def codeline_to_md(node):
    ret = ''
    for e in node:
        ret += highlight_to_md(e)
    return ret


def highlight_to_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'sp':
            ret += sp_to_txt(e)
        elif e.tag == 'ref':
            ret += ref_text_to_txt(e)
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def sp_to_txt(node):
    ret = ''
    if node.get('value') is not None:
        ret += " "*int(node.get('value'))
    else:
        ret += " "
    if node.text is not None:
        ret += node.text
    return ret


def doc_sect1_to_md(node):
    ret = ''
    ret += "\n## "
    if node.findtext('title') is not None:
        ret += node.findtext('title')
    ret += "\n\n"
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'title':
            pass
        elif e.tag == 'para':
            ret += doc_para_to_md(e)
        elif e.tag == 'sect2':
            ret += doc_sect2_to_md(e)
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_sect2_to_md(node):
    ret = ''
    ret += "\n### "
    if node.findtext('title') is not None:
        ret += node.findtext('title')
    ret += "\n\n"
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'title':
            pass
        elif e.tag == 'para':
            ret += doc_para_to_md(e)
        elif e.tag == 'sect3':
            ret += doc_sect3_to_md(e)
        else:
            print("unknown tag in docSect2Type: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_sect3_to_md(node):
    ret = ''
    ret += "\n#### "
    if node.findtext('title') is not None:
        ret += node.findtext('title')
    ret += "\n\n"
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'title':
            pass
        elif e.tag == 'para':
            ret += doc_para_to_md(e)
        elif e.tag == 'sect4':
            ret += doc_sect4_to_md(e)
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_sect4_to_md(node):
    ret = ''
    ret += "\n##### "
    if node.findtext('title') is not None:
        ret += node.findtext('title')
    ret += "\n\n"
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'title':
            pass
        elif e.tag == 'para':
            ret += doc_para_to_md(e)
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_title_to_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        grp = doc_title_cmd_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_para_to_md(node):
    ret = ''
    if node.text is not None:
        ret += node.text
    for e in node:
        grp = doc_cmd_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    return ret


def doc_url_link_to_md(node):
    ret = ''
    ret += '['
    if node.text is not None:
        ret += node.text
    for e in node:
        grp = doc_title_cmd_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    ret += "]("+node.get('url')+")"
    return ret


def doc_anchor_to_md(node):
    return ''


def doc_list_to_md_ordered(node):
    ret = "\n"
    for e in node:
        if e.tag == 'listitem':
            ret += doc_list_item_to_md_ordered(e)
        else:
            print("unknown tag: "+e.tag)
    return ret


def doc_list_to_md_unordered(node):
    ret = "\n"
    for e in node:
        if e.tag == 'listitem':
            ret += doc_list_item_to_md_unordered(e)
        else:
            print("unknown tag: "+e.tag)
    return ret


def doc_list_item_to_md_ordered(node):
    ret = "1. "
    for e in node:
        if e.tag == 'para':
            #ret += doc_para_to_md(e)
            ret += textwrap.indent(doc_para_to_md(e), '   ')[3:]
        else:
            print("unknown tag: "+e.tag)
    return ret + "\n"


def doc_list_item_to_md_unordered(node):
    ret = "* "
    for e in node:
        if e.tag == 'para':
            #ret += doc_para_to_md(e)
            ret += textwrap.indent(doc_para_to_md(e), "  ")[2:]
        else:
            print("unknown tag: "+e.tag)
    return ret + "\n"


def doc_list_item_to_md_varlist(node):
    ret = ":"
    for e in node:
        if e.tag == 'para':
            #ret += doc_para_to_md(e)
            ret += textwrap.indent(doc_para_to_md(e), "    ")[1:]
        else:
            print("unknown tag: "+e.tag)
    return ret + "\n\n"


def doc_simple_sect_to_md(node):
    if node.get('kind') == 'return':
        ret = '#### Returns\n'
        for e in node:
            if e.tag == 'para':
                ret += doc_para_to_md(e)
            else:
                print("unknown tag: "+e.tag)
        return ret
    ret = "{{% alert title=\""
    if node.findtext('title') is not None:
        ret += node.findtext('title')
    else:
        ret += node.get('kind').title()
    ret += "\" color=\""+node.get('kind')+"\" %}}\n"
    for e in node:
        if e.tag == 'para':
            #ret += doc_para_to_md(e)
            ret += textwrap.indent(doc_para_to_md(e), '   ')
        else:
            print("unknown tag: "+e.tag)
    return ret + "\n{{% /alert %}}"


def doc_var_list_entry_to_md(node):
    ret = ""
    for e in node:
        if e.tag == 'term':
            ret += doc_title_to_md(e)
        else:
            print("unknown tag in docVarListEntryType: "+e.tag)
    return ret


def doc_variable_list_group_to_md(e):
    if e.tag == 'varlistentry':
        return doc_var_list_entry_to_md(e)+"\n"
    if e.tag == 'listitem':
        return doc_list_item_to_md_varlist(e)
    return None


def doc_variable_list_to_md(node):
    ret = ''
    for e in node:
        grp = doc_variable_list_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag in docVariableListType: "+e.tag)
    return ret


def doc_table_to_md(node):
    ret = "\n\n"
    for e in node:
        if e.tag == 'row':
            ret += doc_row_to_md(e)
        else:
            print("unknown tag in docTableType: "+e.tag)
    return ret+"\n\n"


def doc_row_to_md(node):
    ret = ""
    for e in node:
        if e.tag == 'entry':
            ret += "| "+doc_entry_to_md(e)
        else:
            print("unknown tag in docEntryType: "+e.tag)
    ret += "|"
    if node.find("./entry[@thead='yes']") is not None:
        ret +=  "\n|"
        for e in node:
            ret +=  "---|"
    return ret + "\n"


def doc_entry_to_md(node):
    ret = ""
    for e in node:
        if e.tag == 'para':
            ret += doc_para_to_md(e)
        else:
            print("unknown tag in docEntryType: "+e.tag)
    return ret


def doc_image_to_md(node):
    os.makedirs(os.path.dirname("static/imgs/"+node.get('name')), exist_ok=True)
    shutil.copyfile(
        os.path.dirname(current_file)+"/"+node.get('name'),
        "static/imgs/"+node.get('name'))
    if node.get('inline') == 'yes':
        ret = '!['
    else:
        ret = '\n\n{{< figure '
        if node.get('height') is not None:
            ret += 'height="'+node.get('height')+'" '
        if node.get('width') is not None:
            ret += 'width="'+node.get('width')+'" '
        ret+= 'caption="'
        if node.get('caption') is not None:
            ret += node.get('caption')+'" title="'
    if node.text is not None:
        ret += node.text
    for e in node:
        grp = doc_title_cmd_group_to_md(e)
        if grp is not None:
            ret += grp
        else:
            print("unknown tag: "+e.tag)
        if e.tail is not None:
            ret += e.tail
    if node.get('inline') == 'yes':
        ret += "](\"/imgs/"+node.get('name')+"\")"
    else:
        ret+="\" src=\"/imgs/"+node.get('name')+"\" >}}"
    return ret


def doc_param_to_md(node):
    ret = ""
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'ref':
            ret += ref_text_to_tt_md(e)
        else:
            print("unknown tag in docParamType: "+e.tag)

        if e.tail is not None:
            ret += e.tail
    return ret


def doc_param_name_to_md(node):
    ret = ""
    if node.text is not None:
        ret += node.text
    for e in node:
        if e.tag == 'ref':
            ret += ref_text_to_tt_md(e)
        else:
            print("unknown tag in docParamName: "+e.tag)

        if e.tail is not None:
            ret += e.tail
    return ret




global anchors, current_file
anchors = {}
for file in sys.argv[1:]:
    current_file = file
    tree = ET.parse(file)
    for compounddef in tree.getroot():
        anchors = generate_page_anchors(compounddef, anchors)
for file in sys.argv[1:]:
    current_file = file
    tree = ET.parse(file)
    for compounddef in tree.getroot():
        print("******* "+compounddef.findtext('compoundname'))
        compounddef_to_md(compounddef)
